# LeRobot数据清洗平台系统架构文档 v3

---

## 第一部分：功能介绍与业务流程

### 1. 产品概述

#### 1.1 版本目标
LeRobot数据清洗平台v3在现有数据可视化和标注功能基础上，全面升级数据处理能力，重点解决机器人轨迹数据中的关节抖动问题和静止帧处理效率问题。

**核心价值**：
- 🎯 **智能抽帧处理**：统一的帧删除管理，支持单帧、帧段、静止片段的精确删除
- 📊 **关节数据分析**：深度分析关节抖动问题，提供量化评估和可视化报告
- 🔧 **轨迹滤波优化**：基于卡尔曼滤波的运动轨迹平滑，提升训练数据质量
- 💾 **五层同步机制**：保持视频、数据、元信息、校验、日志的完整同步删除

#### 1.2 影响范围
- **前端界面**：`templates/visualize_dataset_template.html` - 抽帧处理界面重构
- **后端核心**：`web/app.py`、`core/dataset_manager.py` - API扩展和业务逻辑
- **新增模块**：
  - `core/joint_analysis.py` - 关节数据分析引擎
  - `core/trajectory_smoothing.py` - 轨迹滤波处理器
  - `analyze_joint_data.py` - 批量数据分析脚本
- **配置扩展**：`config.yaml` - 处理参数配置

#### 1.3 设计原则
- **数据驱动**：基于实际数据分析结果设计滤波参数和处理策略
- **模块化架构**：保持前端轻逻辑，后端统一通过`DatasetManager`调度
- **安全可靠**：所有删除和写入操作遵循现有锁+备份+原子替换流程
- **用户友好**：提供直观的操作界面和详细的处理反馈

### 2. 系统现状分析

#### 2.1 已实现功能（v2基础）
- ✅ **五层同步删除**：视频(FFmpeg)、Parquet数据、元数据(episodes.jsonl)、校验、操作日志的完整同步
- ✅ **静止帧检测**：基于帧差法的视频运动分析，支持多视角检测
- ✅ **数据可视化**：时间序列数据的交互式图表展示
- ✅ **备份机制**：自动数据集备份和恢复功能

#### 2.2 存在的限制点
- ❌ **操作入口分散**：删除功能散布在多个界面，用户体验不统一
- ❌ **静止帧处理效率低**：需手动选择视角，无法快速处理多视角结果
- ❌ **关节数据质量问题**：
  - 关节角度存在显著观测噪声（帧间差 0.36°~1.11°）
  - 瞬时跳变可达 7.9°，影响训练稳定性
  - 缺少系统性的数据质量评估和优化工具
- ❌ **预览功能缺失**：删除前无法预览效果，操作风险较高

### 3. 用户角色与使用场景

#### 3.1 主要用户
**数据处理工程师**：
- 工作环境：实验室/办公室，需要处理大量机器人轨迹数据
- 专业要求：了解机器人学基础，能够判断数据质量问题
- 工作模式：批量处理为主，需要高效的自动化工具

#### 3.2 核心使用场景
1. **数据质量评估**：分析关节数据中的噪声和异常，生成质量报告
2. **静止片段清理**：快速识别和删除视频中的静止片段，减少无效数据
3. **轨迹数据优化**：对关节角度序列进行滤波处理，提升数据平滑性
4. **批量数据处理**：对整个数据集进行系统性的清洗和优化

### 4. 抽帧处理界面设计

#### 4.1 界面重构概览
将原"静止帧检测与删除"模块重命名为"抽帧处理"，采用统一的卡片式布局，拆分为三个功能模块：

```
抽帧处理模块
├── 删除单帧 [卡片1]
│   ├── 帧号输入框
│   ├── "填入当前帧" 按钮
│   └── "删除帧" 执行按钮
├── 删除帧段 [卡片2]
│   ├── 起始帧输入框 + "设为当前帧" 按钮
│   ├── 结束帧输入框 + "设为当前帧" 按钮
│   ├── 区间校验提示
│   └── "删除帧段" 执行按钮
└── 静止片段巡查 [卡片3]
    ├── "检测静止片段" 按钮
    ├── 检测结果下拉列表
    │   ├── 片段信息：起始-结束帧 (持续时间/覆盖视角)
    │   ├── "循环预览" 按钮
    │   └── "删除此片段" 按钮
    ├── "删除所有静止片段" 批量按钮
    └── 检测统计信息显示
```

#### 4.2 删除单帧功能设计

**交互流程**：
1. 用户在输入框中输入要删除的帧号
2. 点击"填入当前帧"可自动填入视频播放器的当前帧号
3. 系统实时校验帧号有效性（0 ≤ 帧号 < 总帧数）
4. 点击"删除帧"触发删除操作

**技术实现**：
```html
<div class="frame-deletion-card">
  <h3>删除单帧</h3>
  <div class="input-group">
    <input type="number" x-model="singleFrame"
           :class="{'error': !isValidFrame(singleFrame)}"
           placeholder="输入帧号">
    <button @click="fillCurrentFrame('single')">填入当前帧</button>
  </div>
  <button @click="deleteSingleFrame()"
          :disabled="!isValidFrame(singleFrame)">
    删除帧
  </button>
  <div x-show="frameError" class="error-message" x-text="frameError"></div>
</div>
```

**后端接口复用**：
```javascript
// 直接复用现有的统一删除API
async function deleteSingleFrame() {
    const response = await fetch(`/api/episode/${episodeId}/delete_frames`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            frame_indices: [this.singleFrame],  // 单帧数组
            create_backup: this.createBackup
        })
    });

    const result = await response.json();
    if (result.success) {
        this.showSuccessMessage(`成功删除第${this.singleFrame}帧`);
        await this.refreshEpisodeData();
    } else {
        this.showErrorMessage(`删除失败: ${result.error}`);
    }
}
```

**校验规则**：
- 帧号必须为非负整数
- 帧号不能超出总帧数范围
- 删除前显示确认对话框，提示"将删除所有视角的第X帧数据"

#### 4.3 删除帧段功能设计

**交互流程**：
1. 分别设置起始帧和结束帧（支持"设为当前帧"快捷填入）
2. 系统实时校验区间合法性（起始帧 < 结束帧）
3. 显示将要删除的帧数统计
4. 执行删除操作

**技术实现**：
```html
<div class="frame-range-deletion-card">
  <h3>删除帧段</h3>
  <div class="range-inputs">
    <div class="input-group">
      <label>起始帧:</label>
      <input type="number" x-model="startFrame">
      <button @click="fillCurrentFrame('start')">设为当前帧</button>
    </div>
    <div class="input-group">
      <label>结束帧:</label>
      <input type="number" x-model="endFrame">
      <button @click="fillCurrentFrame('end')">设为当前帧</button>
    </div>
  </div>
  <div class="validation-info">
    <span x-show="isValidRange" class="success">
      将删除 <span x-text="endFrame - startFrame + 1"></span> 帧数据
    </span>
    <span x-show="!isValidRange" class="error" x-text="rangeError"></span>
  </div>
  <button @click="deleteFrameRange()" :disabled="!isValidRange">
    删除帧段
  </button>
</div>
```

**后端接口复用**：
```javascript
// 生成帧索引数组，调用现有API
async function deleteFrameRange() {
    // 生成连续帧索引数组
    const frameIndices = [];
    for (let i = this.startFrame; i <= this.endFrame; i++) {
        frameIndices.push(i);
    }

    const response = await fetch(`/api/episode/${episodeId}/delete_frames`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            frame_indices: frameIndices,  // 帧段数组
            create_backup: this.createBackup
        })
    });

    const result = await response.json();
    if (result.success) {
        this.showSuccessMessage(`成功删除帧段 ${this.startFrame}-${this.endFrame}`);
        await this.refreshEpisodeData();
    } else {
        this.showErrorMessage(`删除失败: ${result.error}`);
    }
}
```

**校验规则**：
- 起始帧 < 结束帧
- 两个帧号都在有效范围内
- 删除前弹窗确认，显示将删除的具体帧数和时间范围

#### 4.4 智能静止片段检测设计

**功能特性**：
- **自动多视角检测**：无需手动选择视角，系统自动检测所有可用视角
- **智能结果合并**：采用并集策略，任一视角检测到的静止片段都会被包含
- **循环预览功能**：点击"查看"可在视频播放器中循环播放该静止片段
- **批量操作支持**：支持单个片段删除和全部片段一键清理

**交互设计**：
```html
<div class="static-detection-card">
  <h3>静止片段巡查</h3>

  <!-- 检测控制 -->
  <div class="detection-controls">
    <button @click="detectStaticSegments()" :disabled="detecting">
      <span x-show="!detecting">检测静止片段</span>
      <span x-show="detecting">检测中...</span>
    </button>
    <div class="detection-params">
      <label>阈值:</label>
      <input type="number" x-model="threshold" step="0.001" value="0.02">
      <label>最小帧数:</label>
      <input type="number" x-model="minFrames" value="5">
    </div>
  </div>

  <!-- 检测结果统计 -->
  <div x-show="staticResults.length > 0" class="detection-summary">
    <p>共发现 <strong x-text="staticResults.length"></strong> 个静止片段，
       覆盖 <strong x-text="totalStaticFrames"></strong> 帧数据
    </p>
  </div>

  <!-- 静止片段列表 -->
  <div x-show="staticResults.length > 0" class="segments-list">
    <div class="segments-dropdown">
      <template x-for="(segment, index) in staticResults" :key="index">
        <div class="segment-item">
          <span class="segment-info">
            第<span x-text="segment.start_frame"></span>-<span x-text="segment.end_frame"></span>帧
            (<span x-text="segment.duration_frames"></span>帧/<span x-text="segment.duration_seconds.toFixed(1)"></span>秒)
            - 覆盖视角: <span x-text="segment.views.join(',')"></span>
          </span>
          <div class="segment-actions">
            <button @click="previewSegment(segment)" class="preview-btn">循环预览</button>
            <button @click="deleteSegment(segment)" class="delete-btn">删除此段</button>
          </div>
        </div>
      </template>
    </div>

    <!-- 批量操作 -->
    <div class="batch-actions">
      <button @click="deleteAllStaticSegments()" class="delete-all-btn">
        删除所有静止片段 (<span x-text="totalStaticFrames"></span>帧)
      </button>
    </div>
  </div>
</div>
```

**后端接口复用说明**：
```javascript
// 删除单个静止片段
async function deleteSegment(segment) {
    const frameIndices = [];
    for (let i = segment.start_frame; i <= segment.end_frame; i++) {
        frameIndices.push(i);
    }

    const response = await fetch(`/api/episode/${episodeId}/delete_frames`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            frame_indices: frameIndices,
            create_backup: this.createBackup
        })
    });

    // 处理结果...
}

// 删除所有静止片段
async function deleteAllStaticSegments() {
    const allFrameIndices = [];

    // 合并所有静止片段的帧索引
    this.staticResults.forEach(segment => {
        for (let i = segment.start_frame; i <= segment.end_frame; i++) {
            if (!allFrameIndices.includes(i)) {
                allFrameIndices.push(i);
            }
        }
    });

    // 排序后调用现有API
    allFrameIndices.sort((a, b) => a - b);

    const response = await fetch(`/api/episode/${episodeId}/delete_frames`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            frame_indices: allFrameIndices,
            create_backup: this.createBackup
        })
    });

    // 处理结果...
}
```

#### 4.5 五层同步删除机制保持

所有删除操作（单帧、帧段、静止片段）都严格遵循现有的五层同步删除流程：

1. **视频层删除**：使用FFmpeg精确删除指定帧，保持视频质量
2. **Parquet数据删除**：删除对应数据行，重建frame_index和timestamp字段
3. **元数据同步**：更新episodes.jsonl中的length字段和相关统计
4. **一致性校验**：验证删除后数据完整性，确保各层数据同步
5. **操作日志**：记录详细的删除操作，支持审计和回滚

**删除执行反馈**：
```javascript
async deleteSingleFrame() {
  try {
    this.isDeleting = true;

    const result = await this.apiClient.deleteFrames(this.episodeId, [this.singleFrame]);

    if (result.success) {
      this.showSuccessMessage(`成功删除第${this.singleFrame}帧，删除${result.deleted}帧数据，耗时${result.processing_time.toFixed(2)}秒`);

      // 刷新页面数据
      await this.refreshEpisodeData();

      // 建议用户刷新确认
      this.showRefreshPrompt();
    } else {
      this.showErrorMessage(`删除失败: ${result.error}`);
    }
  } catch (error) {
    this.showErrorMessage(`操作异常: ${error.message}`);
  } finally {
    this.isDeleting = false;
  }
}
```

#### 4.6 用户体验优化

**状态提示**：
- 删除过程中显示进度指示器
- 操作完成后显示详细结果（删除帧数、耗时、备份状态）
- 错误情况下提供明确的错误信息和解决建议

**快捷操作**：
- 支持键盘快捷键（D键删除当前帧、Shift+D删除帧段）
- "填入当前帧"按钮与视频播放器实时同步
- 记住用户最近的参数设置（阈值、最小帧数等）

**安全机制**：
- 重要操作前弹出确认对话框
- 显示操作影响范围（将删除多少帧、多少秒数据）
- 保持现有的备份开关，默认启用备份保护

---

## 第二部分：系统架构与技术设计

### 5. 后端架构升级

#### 5.1 复用现有删除机制

**现有基础设施**：
- `DatasetManager.delete_frames()` 方法已完善实现五层同步删除
- API `/api/episode/<id>/delete_frames` 支持单帧/帧段/批量删除
- 具备完整的锁机制、备份机制、原子替换流程

**抽帧处理实现**：
前端通过现有API实现所有删除功能，无需后端修改：
```python
# 现有API已支持的调用方式
POST /api/episode/<id>/delete_frames
{
    "frame_indices": [10],              # 单帧删除
    "create_backup": true
}

POST /api/episode/<id>/delete_frames
{
    "frame_indices": [10, 11, 12, 13],  # 帧段删除
    "create_backup": true
}

POST /api/episode/<id>/delete_frames
{
    "frame_indices": [45, 46, 89, 90],  # 静止片段删除
    "create_backup": true
}
```

#### 5.2 新增轨迹滤波功能

**DatasetManager扩展**：
```python
class DatasetManager:
    def smooth_trajectory(self, episode_id: int,
                         target_columns: List[str] = ["action", "observation.state"],
                         kalman_config: Dict = None,
                         create_backup: bool = True) -> Dict[str, Any]:
        """
        对指定episode的关节数据进行卡尔曼滤波平滑

        Args:
            episode_id: 目标episode ID
            target_columns: 要滤波的数据列 (默认: action, observation.state)
            kalman_config: 卡尔曼滤波参数配置
            create_backup: 是否创建备份

        Returns:
            处理结果统计信息
        """
```

**API接口设计**：
```python
@app.route('/api/episode/<int:episode_id>/smooth_trajectory', methods=['POST'])
def smooth_trajectory(episode_id):
    """轨迹平滑API接口"""
    data = request.get_json()

    result = current_dataset_manager.smooth_trajectory(
        episode_id=episode_id,
        target_columns=data.get('target_columns', ['action', 'observation.state']),
        kalman_config=data.get('kalman_config', {}),
        create_backup=data.get('create_backup', True)
    )

    return jsonify({
        "ok": True,
        "episode_id": episode_id,
        "result": result
    })
```

### 6. 轨迹滤波处理系统

### 6. 轨迹滤波处理系统

#### 6.1 滤波需求分析

**关节数据抖动问题**：
- 关节角度存在显著观测噪声，帧间平均差值达 0.36°~1.11°
- 瞬时跳变高达 7.9°，严重影响训练数据质量
- 需要通过卡尔曼滤波去除抖动，提升数据平滑性

**滤波目标**：
- 降低关节数据噪声，减少帧间跳变
- 保持运动轨迹的本质特征
- 更新parquet文件和相关元数据

#### 6.2 数据处理完整流程

**6.2.1 Parquet数据读取**

```python
def _load_episode_data(self, episode_id: int) -> pd.DataFrame:
    """
    读取episode的parquet数据

    流程:
    1. 根据episode_id计算chunk和文件路径
    2. 验证parquet文件存在性
    3. 使用pandas读取完整DataFrame
    4. 验证必要字段存在 (action, observation.state)
    5. 检查数据完整性 (帧数、数据类型)

    Returns:
        完整的episode数据DataFrame
    """
    # 获取parquet文件路径 (复用现有逻辑)
    parquet_path = self.config.get_data_path(episode_id)

    if not parquet_path.exists():
        raise FileNotFoundError(f"Episode {episode_id} parquet文件不存在: {parquet_path}")

    # 读取parquet文件
    df = pd.read_parquet(parquet_path)

    # 验证必要字段
    required_columns = ['action', 'observation.state']
    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        raise ValueError(f"缺少必要字段: {missing_columns}")

    # 验证数据类型和结构
    self._validate_joint_data_structure(df)

    return df

def _validate_joint_data_structure(self, df: pd.DataFrame) -> None:
    """
    验证关节数据结构

    检查项:
    1. action和observation.state都是6维数组
    2. 数据类型为float
    3. 无NaN值或异常数据
    """
    for column in ['action', 'observation.state']:
        # 检查数据维度
        sample_data = df[column].iloc[0]
        if not isinstance(sample_data, (list, np.ndarray)) or len(sample_data) != 6:
            raise ValueError(f"{column} 数据不是6维数组")

        # 检查是否有NaN值
        joint_arrays = np.stack(df[column].values)
        if np.any(np.isnan(joint_arrays)):
            raise ValueError(f"{column} 包含NaN值")
```

**6.2.2 卡尔曼滤波处理**

```python
def _apply_kalman_filtering(self, data_df: pd.DataFrame,
                          target_columns: List[str],
                          kalman_config: Dict = None) -> pd.DataFrame:
    """
    对指定列的关节数据应用卡尔曼滤波

    Args:
        data_df: 原始数据DataFrame
        target_columns: 要滤波的列名列表
        kalman_config: 滤波参数配置

    Returns:
        滤波后的数据DataFrame
    """
    filtered_df = data_df.copy()
    processing_stats = {}

    for column in target_columns:
        if column not in data_df.columns:
            continue

        # 提取关节数据 (N x 6 数组)
        joint_arrays = np.stack(data_df[column].values)
        n_frames, n_joints = joint_arrays.shape

        filtered_joints = np.zeros_like(joint_arrays)
        joint_stats = []

        # 对每个关节分别应用滤波
        for joint_idx in range(n_joints):
            joint_data = joint_arrays[:, joint_idx]

            # 创建Kalman1D滤波器
            kalman_filter = self._create_kalman_filter(joint_data, kalman_config)

            # 应用滤波
            filtered_data = kalman_filter.smooth(joint_data)
            filtered_joints[:, joint_idx] = filtered_data

            # 计算滤波效果统计
            stats = self._compute_filtering_stats(joint_data, filtered_data)
            joint_stats.append(stats)

        # 将滤波结果转换回原始格式
        filtered_df[column] = [row.tolist() for row in filtered_joints]

        processing_stats[column] = {
            'joints_processed': n_joints,
            'frames_processed': n_frames,
            'joint_stats': joint_stats,
            'average_noise_reduction': np.mean([s['noise_reduction'] for s in joint_stats]),
            'max_deviation': np.max([s['max_deviation'] for s in joint_stats])
        }

    return filtered_df, processing_stats

def _create_kalman_filter(self, joint_data: np.ndarray, config: Dict = None) -> 'Kalman1D':
    """
    创建并配置Kalman1D滤波器

    配置流程:
    1. 自动估计噪声参数 (基于帧间差分)
    2. 应用用户配置的倍率调整
    3. 初始化滤波器状态
    """
    from .kalman_filter import Kalman1D

    # 创建滤波器实例
    kalman = Kalman1D(dt=1/30.0)  # 假设30fps

    # 自动估计噪声参数
    frame_diffs = np.diff(joint_data)
    measurement_noise_var = np.var(frame_diffs)

    # 应用用户配置的倍率
    if config:
        measurement_noise_var *= config.get('measurement_noise_scale', 1.0)

    # 配置滤波器参数
    kalman.configure_noise_parameters(measurement_noise_var)

    return kalman

def _compute_filtering_stats(self, original: np.ndarray, filtered: np.ndarray) -> Dict:
    """
    计算滤波效果统计指标

    指标包括:
    - 噪声降低率 (帧间差分方差的改善)
    - 最大偏差
    - 信号保真度 (相关系数)
    - RMSE
    """
    # 计算帧间差分方差改善
    original_diff_var = np.var(np.diff(original))
    filtered_diff_var = np.var(np.diff(filtered))
    noise_reduction = 1 - (filtered_diff_var / original_diff_var) if original_diff_var > 0 else 0

    # 最大偏差
    max_deviation = np.max(np.abs(original - filtered))

    # 信号保真度
    correlation = np.corrcoef(original, filtered)[0, 1] if len(original) > 1 else 1.0

    # RMSE
    rmse = np.sqrt(np.mean((original - filtered) ** 2))

    return {
        'noise_reduction': max(0, noise_reduction),
        'max_deviation': max_deviation,
        'signal_fidelity': correlation,
        'rmse': rmse
    }
```

**6.2.3 Parquet文件原子更新**

```python
def _update_parquet_file(self, episode_id: int, updated_df: pd.DataFrame) -> None:
    """
    原子更新parquet文件

    安全流程:
    1. 创建临时文件
    2. 写入更新数据到临时文件
    3. 验证临时文件完整性
    4. 原子重命名替换原文件
    5. 清理临时文件
    """
    parquet_path = self.config.get_data_path(episode_id)
    temp_path = parquet_path.with_suffix('.tmp')

    try:
        # 写入临时文件
        updated_df.to_parquet(temp_path, index=False)

        # 验证临时文件
        self._verify_parquet_file(temp_path, expected_rows=len(updated_df))

        # 原子重命名 (确保操作的原子性)
        temp_path.replace(parquet_path)

        logging.info(f"成功更新parquet文件: {parquet_path}")

    except Exception as e:
        # 清理临时文件
        if temp_path.exists():
            temp_path.unlink()
        raise RuntimeError(f"更新parquet文件失败: {e}")

def _verify_parquet_file(self, file_path: Path, expected_rows: int) -> None:
    """
    验证parquet文件完整性

    检查项:
    1. 文件可正常读取
    2. 行数匹配
    3. 必要字段存在
    4. 数据类型正确
    """
    try:
        df = pd.read_parquet(file_path)

        if len(df) != expected_rows:
            raise ValueError(f"行数不匹配: 期望 {expected_rows}, 实际 {len(df)}")

        # 验证关节数据结构
        self._validate_joint_data_structure(df)

    except Exception as e:
        raise ValueError(f"parquet文件验证失败: {e}")
```

**6.2.4 元数据文件同步更新**

```python
def _update_metadata_after_smoothing(self, episode_id: int,
                                    processing_stats: Dict) -> None:
    """
    滤波处理后更新相关元数据文件

    更新内容:
    1. episodes.jsonl - 添加处理时间戳和标记
    2. episodes_stats.jsonl - 更新统计信息 (如有)
    3. ops_logs - 记录操作详情
    4. info.json - 通常无需更新 (帧数未变)
    """

    # 1. 更新episodes.jsonl
    self._update_episodes_metadata(episode_id, processing_stats)

    # 2. 记录操作日志
    self._record_smoothing_operation(episode_id, processing_stats)

    # 3. 可选：更新episodes_stats.jsonl
    if hasattr(self, 'stats_manager'):
        self._update_episode_stats(episode_id, processing_stats)

def _update_episodes_metadata(self, episode_id: int, stats: Dict) -> None:
    """
    更新episodes.jsonl中的episode记录

    添加字段:
    - trajectory_smoothed: True
    - smoothing_timestamp: 处理时间
    - smoothing_stats: 简化统计信息
    """
    episodes_path = self.config.get_episodes_path()

    # 读取现有数据
    episodes_data = []
    if episodes_path.exists():
        with open(episodes_path, 'r') as f:
            episodes_data = [json.loads(line) for line in f if line.strip()]

    # 查找并更新对应episode
    updated = False
    for episode in episodes_data:
        if episode.get('episode_index') == episode_id:
            episode['trajectory_smoothed'] = True
            episode['smoothing_timestamp'] = datetime.now().isoformat()
            episode['smoothing_stats'] = {
                'avg_noise_reduction': stats.get('average_noise_reduction', 0),
                'max_deviation': stats.get('max_deviation', 0),
                'processed_columns': list(stats.keys())
            }
            updated = True
            break

    if not updated:
        # 如果episode不存在，创建新记录
        episodes_data.append({
            'episode_index': episode_id,
            'trajectory_smoothed': True,
            'smoothing_timestamp': datetime.now().isoformat(),
            'smoothing_stats': stats
        })

    # 写回文件
    with open(episodes_path, 'w') as f:
        for episode in episodes_data:
            f.write(json.dumps(episode) + '\n')

def _record_smoothing_operation(self, episode_id: int, stats: Dict) -> None:
    """
    记录轨迹滤波操作到ops_logs

    记录内容:
    - 操作类型: trajectory_smoothing
    - 处理的列和统计信息
    - 执行时间和结果
    """
    log_entry = {
        'timestamp': datetime.now().isoformat(),
        'operation': 'trajectory_smoothing',
        'episode_id': episode_id,
        'processing_stats': stats,
        'success': True
    }

    # 写入ops_logs (假设有统一的日志记录机制)
    self._append_operation_log(log_entry)
```

#### 6.3 卡尔曼滤波器实现

**核心滤波器模块**：`core/kalman_filter.py`

```python
import numpy as np
from typing import Tuple

class Kalman1D:
    """
    一维卡尔曼滤波器，专用于单关节角度滤波

    状态向量: [角度, 角速度]
    观测向量: [角度]
    """

    def __init__(self, dt: float = 1/30.0):
        self.dt = dt  # 时间间隔 (基于fps)

        # 状态转移矩阵 F: [1, dt; 0, 1]
        self.F = np.array([[1.0, dt], [0.0, 1.0]])

        # 观测矩阵 H: [1, 0]
        self.H = np.array([[1.0, 0.0]])

        # 噪声参数 (通过数据自动估计)
        self.Q = None  # 过程噪声协方差
        self.R = None  # 观测噪声协方差
        self.P = None  # 状态协方差

    def configure_noise_parameters(self, measurement_noise_var: float) -> None:
        """
        基于测量噪声方差配置滤波参数
        """
        # 观测噪声
        self.R = measurement_noise_var

        # 过程噪声 (假设角速度变化相对较小)
        velocity_var = measurement_noise_var * 0.1
        acceleration_var = velocity_var * 0.1

        self.Q = np.array([
            [self.dt**4/4 * acceleration_var, self.dt**3/2 * acceleration_var],
            [self.dt**3/2 * acceleration_var, self.dt**2 * acceleration_var]
        ])

        # 初始状态协方差
        self.P = np.eye(2) * 1.0

    def smooth(self, joint_data: np.ndarray) -> np.ndarray:
        """
        对关节角度序列应用卡尔曼滤波

        Args:
            joint_data: 原始关节角度序列 (N,)

        Returns:
            滤波后的关节角度序列 (N,)
        """
        n_points = len(joint_data)
        smoothed = np.zeros(n_points)

        # 初始状态: [初始角度, 0角速度]
        x = np.array([joint_data[0], 0.0])

        for i in range(n_points):
            # 预测步骤
            x_pred = self.F @ x
            P_pred = self.F @ self.P @ self.F.T + self.Q

            # 更新步骤
            y = joint_data[i] - self.H @ x_pred  # 测量残差
            S = self.H @ P_pred @ self.H.T + self.R  # 残差协方差
            K = P_pred @ self.H.T / S  # 卡尔曼增益

            x = x_pred + K * y
            self.P = (np.eye(2) - K @ self.H) @ P_pred

            smoothed[i] = x[0]  # 提取角度估计

        return smoothed
```

#### 6.4 Web界面集成设计

**轨迹平滑控制面板**：
集成到现有的`templates/visualize_dataset_template.html`，添加简化的轨迹滤波功能：

```html
<div class="trajectory-smoothing-card">
  <h3>运动轨迹平滑</h3>

  <!-- 目标列选择 -->
  <div class="target-selection">
    <label>处理目标:</label>
    <select x-model="selectedColumn">
      <option value="observation.state">观测状态 (observation.state)</option>
      <option value="action">动作数据 (action)</option>
    </select>
  </div>

  <!-- 滤波参数 -->
  <div class="smoothing-params">
    <div class="param-group">
      <label>过程噪声倍率:</label>
      <input type="range" x-model="processNoiseScale" min="0.5" max="2.0" step="0.1">
      <span x-text="processNoiseScale"></span>
    </div>
    <div class="param-group">
      <label>观测噪声倍率:</label>
      <input type="range" x-model="measurementNoiseScale" min="0.5" max="2.0" step="0.1">
      <span x-text="measurementNoiseScale"></span>
    </div>
  </div>

  <!-- 操作按钮 -->
  <div class="action-buttons">
    <button @click="previewSmoothing()" :disabled="isProcessing">预览效果</button>
    <button @click="executeSmoothing()" :disabled="!canExecute || isProcessing">执行平滑</button>
  </div>

  <!-- 结果显示 -->
  <div x-show="smoothingResult" class="result-display">
    <p>处理完成：噪声降低 <span x-text="smoothingResult.noise_reduction"></span>%</p>
  </div>
</div>
```

**API接口设计**：
```python
@app.route('/api/episode/<int:episode_id>/smooth_trajectory', methods=['POST'])
def smooth_trajectory(episode_id):
    """轨迹平滑API"""
    data = request.get_json()

    # 获取DatasetManager实例
    current_dataset_manager = DatasetManager(current_dataset_path, app_config)

    # 执行轨迹平滑
    result = current_dataset_manager.smooth_trajectory(
        episode_id=episode_id,
        target_columns=[data.get('target_column', 'observation.state')],
        process_noise_scale=data.get('process_noise_scale', 1.0),
        measurement_noise_scale=data.get('measurement_noise_scale', 1.0),
        preview_only=data.get('preview_only', False),
        create_backup=data.get('create_backup', True)
    )

    return jsonify({"ok": True, "result": result})
```

#### 6.5 自动数据刷新机制设计

**功能需求分析**：
当前删除操作完成后使用 `window.location.reload()` 整页刷新存在以下问题：
- 用户体验差：丢失当前操作状态（视频播放位置、图表缩放等）
- 需要手动确认：不够自动化
- 效率低：重新加载整个页面资源

**解决方案**：
实现删除后自动从文件重新读取最新数据并局部刷新页面，确保使用的是执行操作后的最新数据。

#### 6.5.1 数据刷新流程设计

**完整刷新流程**：
```
删除操作成功 → 保存当前状态 → 重新读取文件数据 → 更新页面组件 → 恢复用户状态
```

**数据重读取策略**：
```python
# 后端数据刷新API设计
@app.route('/api/episode/<int:episode_id>/refresh_data', methods=['GET'])
def api_refresh_episode_data(episode_id: int):
    """删除后刷新episode数据API - 强制从文件重读"""
    try:
        # 获取当前数据集配置
        current_dataset_path = session.get('dataset_path', dataset_path)

        # 重新创建DataLoader实例，避免使用缓存
        current_data_loader = LocalDatasetLoader(current_dataset_path)
        current_dataset_config = DatasetConfig(current_dataset_path)
        current_video_handler = VideoHandler(current_dataset_config, current_data_loader)

        # 强制重新读取parquet文件数据
        episode_data_csv = current_data_loader.load_episode_data(episode_id, force_reload=True)

        # 重新获取视频信息（总帧数等）
        videos_info = current_video_handler.get_video_info(episode_id)

        # 重新读取数据集统计信息
        dataset_info = {
            "repo_id": f"local/{Path(current_dataset_path).name}",
            "num_samples": current_data_loader.info.total_frames,
            "num_episodes": current_data_loader.info.total_episodes,
            "fps": current_data_loader.info.fps
        }

        return jsonify({
            "success": True,
            "episode_data_csv": episode_data_csv,
            "videos_info": videos_info,
            "dataset_info": dataset_info,
            "columns": current_data_loader.get_columns_info(episode_id)
        })

    except Exception as e:
        logger.error(f"Error refreshing episode {episode_id} data: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
```

#### 6.5.2 前端自动刷新机制

**状态保存与恢复**：
```javascript
async function refreshDataAfterDeletion(deletionResult) {
    try {
        // 1. 保存当前用户状态
        const userState = {
            currentTime: this.video ? this.video.currentTime : 0,
            dygraphTime: this.dygraphTime,
            selectedVideoKeys: [...this.videosKeysSelected],
            chartZoom: this.dygraph ? this.dygraph.xAxisRange() : null,
            chartSelection: this.dygraph ? this.dygraph.getSelection() : null
        };

        // 2. 显示刷新进度
        this.showRefreshProgress("正在重新读取数据...");

        // 3. 调用后端API重新读取文件数据
        const response = await fetch(`/api/episode/{{ episode_id }}/refresh_data`);
        const refreshData = await response.json();

        if (!refreshData.success) {
            throw new Error(refreshData.error);
        }

        // 4. 更新CSV数据并重新初始化图表
        await this.updateChartWithNewData(refreshData.episode_data_csv);

        // 5. 更新视频信息和总帧数
        this.updateVideoInfo(refreshData.videos_info);

        // 6. 更新数据集统计信息
        this.updateDatasetInfo(refreshData.dataset_info);

        // 7. 恢复用户状态
        await this.restoreUserState(userState, deletionResult.deleted);

        // 8. 显示成功消息
        this.showSuccessMessage(`删除成功！删除了 ${deletionResult.deleted} 帧，数据已自动更新。`);

    } catch (error) {
        console.error('自动刷新失败:', error);
        // 回退到整页刷新
        if (confirm(`数据自动刷新失败：${error.message}\n是否重新加载页面？`)) {
            window.location.reload();
        }
    } finally {
        this.hideRefreshProgress();
    }
}
```

**图表数据更新**：
```javascript
async function updateChartWithNewData(csvDataStr) {
    // 创建新的CSV数据URL
    const blob = new Blob([csvDataStr], { type: 'text/csv;charset=utf-8;' });
    const newCsvUrl = URL.createObjectURL(blob);

    // 保存当前图表配置
    const currentOptions = this.dygraph.getOptions();

    // 销毁旧图表并创建新图表
    this.dygraph.destroy();
    this.dygraph = new Dygraph(document.getElementById("graph"), newCsvUrl, {
        ...currentOptions,
        drawCallback: (dygraph, is_initial) => {
            if (is_initial) {
                // 初始化完成后的处理
                this.colors = this.dygraph.getColors();
                this.dygraph.updateOptions({ colors: this.colors });
            }
        }
    });

    // 清理旧的URL
    URL.revokeObjectURL(newCsvUrl);
}
```

**智能状态恢复**：
```javascript
async function restoreUserState(userState, deletedFrameCount) {
    // 调整时间位置（考虑删除的帧数）
    let adjustedTime = userState.currentTime;

    // 如果删除的是当前播放位置之前的帧，需要调整时间
    if (deletedFrameCount > 0) {
        const deletedDuration = deletedFrameCount / {{ dataset_info.fps }};
        if (userState.currentTime > deletedDuration) {
            adjustedTime = Math.max(0, userState.currentTime - deletedDuration);
        }
    }

    // 恢复视频播放位置
    if (this.video && adjustedTime >= 0) {
        this.video.currentTime = adjustedTime;
        this.videos.forEach(video => {
            video.currentTime = adjustedTime;
        });
    }

    // 恢复图表选择和缩放
    if (userState.chartZoom) {
        this.dygraph.updateOptions({ dateWindow: userState.chartZoom });
    }

    if (userState.chartSelection !== null) {
        this.dygraph.setSelection(userState.chartSelection);
    }

    // 恢复视频选择
    this.videosKeysSelected = userState.selectedVideoKeys;
}
```

#### 6.5.3 数据一致性保证

**强制文件重读机制**：
- DataLoader添加 `force_reload` 参数，跳过内存缓存
- VideoHandler重新扫描视频文件获取最新帧数
- 清除所有相关的内存缓存，确保数据来源于文件系统

**错误处理与回退**：
- 自动刷新失败时提供整页刷新选项
- 网络错误时显示明确的错误信息
- 数据不一致时触发完整重载

**性能优化**：
- 仅重新读取必要的数据文件
- 异步加载，不阻塞用户界面
- 进度指示器显示刷新状态


## 第三部分：具体实施步骤

### 8. 开发里程碑规划

#### 里程碑 M1：抽帧处理界面重构 (1天)
**目标**：统一帧删除操作入口，提升用户体验和操作效率

**任务清单**：
1. **前端界面重构** `templates/visualize_dataset_template.html`
   - 删除单帧卡片：输入框+填入当前帧+校验+执行
   - 删除帧段卡片：起始/结束帧+当前帧标记+区间校验
   - 静止片段巡查卡片：自动检测+列表展示+循环预览+批量删除
   - 统一的操作反馈和状态提示

2. **后端API优化** `web/app.py`
   - 增强静止帧检测API，支持多视角并集结果
   - 统一删除API，支持单帧/帧段/批量模式
   - 添加删除预览功能，显示影响范围
   - 保持现有五层同步删除机制
   - **新增数据刷新API**：`/api/episode/<id>/refresh_data`，强制从文件重读最新数据

3. **循环预览功能实现**
   - 视频播放器循环模式控制
   - 预览状态指示器
   - 一键退出预览功能

4. **自动数据刷新功能实现**
   - 删除成功后自动调用数据刷新，替换 `window.location.reload()`
   - 实现状态保存与智能恢复（视频播放位置、图表缩放、用户选择）
   - 强制从文件系统重新读取parquet数据和视频信息
   - 局部更新页面组件，避免整页刷新
   - 错误处理与回退机制

**验收标准**：
- [ ] 三个功能卡片布局合理，操作直观
- [ ] "填入当前帧"功能与视频播放器实时同步
- [ ] 静止片段检测自动覆盖所有视角，结果准确
- [ ] 循环预览功能流畅，能够准确循环播放指定片段
- [ ] 所有删除操作严格遵循五层同步删除流程
- [ ] 删除操作提供详细的处理反馈和结果统计
- [ ] **删除后自动刷新数据**：无需手动确认，自动从文件重读最新数据
- [ ] **状态保持功能**：刷新后保持用户的视频播放位置和图表状态
- [ ] **数据一致性保证**：确保页面显示的是执行操作后的最新文件数据

#### 里程碑 M2：轨迹滤波系统实现 (2天)
**目标**：实现基于卡尔曼滤波的轨迹平滑功能，显著改善数据质量

**任务清单**：
1. **滤波算法实现** `core/trajectory_smoothing.py`
   - `Kalman1D` 单关节卡尔曼滤波器
   - 参数自适应估计算法（基于噪声特性）
   - 质量评估指标计算（噪声降低、平滑性改善等）
   - DatasetManager集成：`smooth_trajectory`方法

2. **Web界面集成** `templates/visualize_dataset_template.html`
   - 运动轨迹平滑控制面板
   - 目标列选择（action/observation.state）
   - 滤波参数调节界面（过程/观测噪声倍率）
   - 预览功能和效果对比展示

3. **API接口开发** `web/app.py`
   - `/api/episode/<id>/smooth_trajectory` 主处理接口
   - `/api/episode/<id>/smooth_trajectory/preview` 预览接口
   - 结果统计和质量指标返回

4. **配置系统扩展** `config.yaml`
   - processing.smoothing配置节点
   - 默认参数和批量处理设置

**验收标准**：
- [ ] 卡尔曼滤波器能够自动根据数据噪声调整参数
- [ ] 滤波后数据噪声水平显著降低（目标：降低50%以上）
- [ ] 预览功能能准确预测滤波效果，与实际结果一致
- [ ] Web界面操作直观，参数调节响应灵敏
- [ ] 滤波操作遵循现有备份和原子替换机制

#### 里程碑 M3：集成测试与文档完善 (1天)
**目标**：确保系统稳定性，完善用户文档和操作指南

**任务清单**：
1. **端到端功能测试**
   - 抽帧处理界面全流程测试
   - 轨迹滤波功能效果验证
   - 各模块集成测试和边界情况验证

2. **性能和稳定性测试**
   - 大数据集处理性能测试（>100 episodes）
   - 内存使用和资源管理验证
   - 错误恢复机制测试

3. **用户文档完善**
   - 更新 CLAUDE.md 项目说明
   - 添加轨迹滤波功能使用指南
   - 故障排除和最佳实践指南

4. **代码优化和清理**
   - 代码风格统一和注释完善
   - 删除临时测试文件和调试代码
   - 日志输出规范化

**验收标准**：
- [ ] 所有新功能通过端到端测试，无严重bug
- [ ] 系统能稳定处理大规模数据集（>500 episodes）
- [ ] 用户文档完整，新用户能够独立使用新功能
- [ ] 代码质量符合项目标准，可维护性良好

### 9. 详细实施计划

#### 9.1 核心功能开发 (4天)

**第1天：抽帧处理界面重构**
```
上午 (9:00-12:00):
├── 重构 templates/visualize_dataset_template.html
├── 实现删除单帧和删除帧段卡片
├── 添加表单校验和用户反馈
└── 前端逻辑测试

下午 (14:00-18:00):
├── 开发静止片段巡查卡片
├── 实现循环预览功能
├── 后端API优化（复用现有delete_frames接口）
├── **新增数据刷新API**：实现强制文件重读功能
└── **自动刷新机制**：替换window.location.reload()为智能局部刷新
```

**第2天：轨迹滤波算法实现**
```
上午 (9:00-12:00):
├── 创建 core/trajectory_smoothing.py
├── 实现 Kalman1D 单关节滤波器
├── 开发参数自适应估计算法
└── 滤波器性能测试

下午 (14:00-18:00):
├── 实现parquet数据读取、滤波、写入流程
├── 质量评估指标计算
├── 算法优化和边界处理
└── DatasetManager集成测试
```

**第3天：Web界面和API集成**
```
上午 (9:00-12:00):
├── 设计运动轨迹平滑控制面板
├── 实现参数调节界面和预览功能
├── 前端与后端API集成
└── 用户交互逻辑完善

下午 (14:00-18:00):
├── 开发后端API接口 (smooth_trajectory)
├── DatasetManager 集成和配置扩展
├── 错误处理和状态反馈
└── 完整功能流程测试
```

**第4天：集成测试与优化**
```
上午 (9:00-12:00):
├── 端到端功能测试和bug修复
├── 性能测试和优化调整
├── 边界情况和异常处理验证
└── 用户体验细节优化

下午 (14:00-18:00):
├── 文档更新和使用指南编写
├── 代码清理和注释完善
├── 最终验收测试
└── 项目交付准备
```

#### 9.2 质量保证计划

**代码质量标准**：
- Python代码遵循PEP8规范，函数复杂度 ≤ 15
- JavaScript代码使用一致的命名和缩进规范
- 关键算法提供充分的单元测试覆盖
- 用户界面响应时间 < 300ms (95th percentile)

**性能指标要求**：
- 静止帧检测：episode < 30s（视频大小依赖）
- 轨迹滤波：单episode < 10s，包含数据写入
- 内存使用：峰值 < 2GB（处理大型episode时）

**测试覆盖范围**：
- 单元测试：核心算法模块 > 80%覆盖率
- 集成测试：完整业务流程端到端验证
- 性能测试：各种数据规模下的处理时间测试
- 兼容性测试：不同浏览器和数据集格式

#### 9.3 风险评估与缓解策略

**技术风险**：

**风险1：卡尔曼滤波参数自适应效果不理想**
- **描述**：不同数据集的噪声特性差异大，自动参数估计可能不准确
- **影响**：滤波效果不佳，用户需要手动调整参数
- **缓解策略**：
  - 提供多种参数估计策略供选择
  - 实现预览功能，让用户在执行前确认效果
  - 保留手动参数调节选项作为备选方案

**风险2：大数据集处理性能问题**
- **描述**：批量处理数百个episodes时，内存占用或处理时间过长
- **影响**：用户体验差，系统响应缓慢
- **缓解策略**：
  - 实现数据流处理，避免全量内存加载
  - 添加进度指示和取消功能
  - 提供批量大小控制，支持分批处理

**风险3：数据完整性风险**
- **描述**：滤波或删除操作可能导致数据损坏或不一致
- **影响**：数据集不可用，影响训练结果
- **缓解策略**：
  - 强制执行备份机制，默认开启
  - 实现操作前预览和确认机制
  - 保持现有的原子替换和一致性校验流程

#### 9.4 项目交付清单

**代码交付**：
- [ ] `core/trajectory_smoothing.py` - 轨迹滤波系统
- [ ] 前端界面更新和API接口扩展
- [ ] 配置文件和测试代码

**文档交付**：
- [ ] 更新后的系统架构文档v3.md
- [ ] 轨迹滤波功能操作手册
- [ ] API接口文档（新增部分）
- [ ] 故障排除和最佳实践指南

**测试报告**：
- [ ] 滤波效果评估报告（前后对比）
- [ ] 功能测试报告和性能基准测试
- [ ] 用户体验测试反馈和改进建议

**培训材料**：
- [ ] 新功能演示和使用指南
- [ ] 数据质量评估和优化最佳实践
- [ ] 常见问题解答和使用技巧

---

### 10. 配置与运维

#### 10.1 配置文件扩展

**config.yaml完整结构**：
```yaml
# LeRobot数据清洗平台配置

app:
  host: "127.0.0.1"
  port: 9090
  debug: false

dataset:
  path: "/home/chenqingyu/robot/lerobot_data/datasets/grasp_dataset"
  cache_enabled: false

# 新增：数据处理配置
processing:
  # 静止帧检测配置
  static_detection:
    enabled: true
    threshold: 0.02
    min_static_frames: 5
    combine_policy: "union"  # union/intersection
    cache_results: true
    cache_duration_hours: 24

  # 轨迹平滑配置
  smoothing:
    enabled: true
    default_targets: ["observation.state", "action"]
    default_method: "kalman"
    auto_tune: true
    process_scale: 1.0
    measurement_scale: 1.0
    batch_size: 10
    preview_threshold: 0.1  # 预览阈值，低于此改善不建议执行

  # 关节数据分析配置
  analysis:
    sample_rate: 1.0  # 分析采样率，1.0表示全量
    cache_reports: true
    output_formats: ["html", "json"]
    anomaly_threshold: 3.0  # 异常检测倍数
```

#### 10.2 性能监控

**关键性能指标**：
- 关节数据分析处理速度（episodes/min）
- 静止帧检测准确率和召回率
- 轨迹滤波质量改善程度（噪声降低%）
- 系统响应时间和内存使用情况

**监控实现建议**：
- 在核心处理函数中添加时间和内存使用统计
- 记录处理结果的质量指标到日志文件
- 提供性能报告API供运维监控使用

#### 10.3 故障排除

**常见问题及解决方案**：

1. **关节数据分析速度慢**
   - 检查数据集规模，考虑使用采样分析
   - 确认系统内存充足，避免频繁交换
   - 检查磁盘I/O性能，使用SSD存储

2. **轨迹滤波效果不佳**
   - 使用分析工具确认数据噪声特性
   - 调整过程/观测噪声倍率参数
   - 考虑使用其他滤波算法（移动平均等）

3. **静止帧检测误报**
   - 调整检测阈值，降低敏感度
   - 增加最小静止帧数要求
   - 检查视频质量和编码格式

---

## 总结

LeRobot数据清洗平台v3通过引入智能抽帧处理、关节数据深度分析和轨迹滤波优化三大核心功能，全面提升了机器人训练数据的质量和处理效率。

**主要成果**：
- 🎯 **统一的抽帧处理界面**：集成单帧、帧段、静止片段删除，提供循环预览和批量操作
- 📊 **数据驱动的质量评估**：量化分析关节数据噪声和异常，建立科学的评估标准
- 🔧 **智能轨迹滤波系统**：基于卡尔曼滤波的自适应参数调整，显著改善数据平滑性
- 💾 **可靠的数据安全机制**：保持现有的五层同步删除和备份恢复体系

**技术特色**：
- 模块化设计，易于扩展和维护
- 数据驱动的参数自适应，减少手动调节需求
- 完善的预览和反馈机制，降低操作风险
- 基于实际数据分析的滤波方案，确保效果可靠

本架构设计为机器人学习领域的数据预处理提供了完整的工具链，通过科学的数据质量评估和优化手段，有效提升训练数据质量，为模型性能改善奠定坚实基础。
