# LeRobot 可视化系统提取与最小架构实现方案

## 1. 项目概述

### 1.1 项目背景
基于对 `/home/chenqingyu/robot/new_lerobot` 项目的深入分析，本方案旨在从复杂的LeRobot机器人学习训练系统中提取核心可视化功能，构建一个轻量级、专注于数据展示的独立可视化工具。

### 1.2 项目目标
- **功能提取**: 从new_lerobot项目中提取Web可视化核心功能
- **架构简化**: 移除深度学习训练相关的复杂依赖，专注数据可视化
- **本地适配**: 专门适配本地数据集 `/home/chenqingyu/robot/new_lerobot/grasp_dataset`
- **轻量化部署**: 构建可独立运行的最小化可视化系统

### 1.3 核心特性
- **多视频同步播放**: 支持laptop/phone双摄像头视角同步展示
- **时间序列数据可视化**: 实时展示机器人状态和动作数据图表
- **Episode导航**: 便捷的数据集episode浏览和选择功能
- **响应式界面**: 基于现代Web技术的用户友好界面

## 2. 原项目分析

### 2.1 核心可视化组件分析

#### 2.1.1 主要可视化文件
```
/home/chenqingyu/robot/new_lerobot/lerobot/scripts/visualize_dataset_html.py
- 文件大小: 479行代码
- 功能: 完整的Flask Web可视化应用
- 技术栈: Flask + Jinja2模板 + RESTful API
```

#### 2.1.2 前端技术栈
```
/home/chenqingyu/robot/new_lerobot/lerobot/templates/visualize_dataset_template.html
- Alpine.js: 轻量级JavaScript框架，处理交互逻辑
- Tailwind CSS: 现代CSS框架，负责样式和布局
- Dygraphs: JavaScript图表库，处理时间序列数据可视化
```

#### 2.1.3 关键依赖分析
```python
# 核心依赖 (必须保留)
from lerobot.common.datasets.utils import IterableNamespace  # 数据结构
from lerobot.common.utils.utils import init_logging          # 日志初始化

# 标准库依赖
import pandas as pd      # 数据处理
import json, csv        # 数据格式转换
from pathlib import Path # 路径处理
from flask import Flask  # Web框架
```

### 2.2 数据集结构分析

#### 2.2.1 本地数据集结构
```
/home/chenqingyu/robot/new_lerobot/grasp_dataset/
├── data/                    # Parquet数据文件
│   └── chunk-000/
├── videos/                  # MP4视频文件
│   └── chunk-000/
│       ├── laptop/         # 笔记本摄像头视角
│       └── phone/          # 手机摄像头视角
├── meta/                   # 元数据文件
│   ├── info.json          # 数据集基本信息
│   ├── episodes.jsonl     # Episode列表
│   └── episodes_stats.jsonl # 统计信息
└── test_dataset/          # 测试数据
```

#### 2.2.2 数据格式规范
```json
// info.json 关键字段
{
  "codebase_version": "v2.1",
  "robot_type": "koch",
  "total_episodes": 701,
  "total_frames": 238279,
  "fps": 30,
  "data_path": "data/chunk-{episode_chunk:03d}/episode_{episode_index:06d}.parquet",
  "video_path": "videos/chunk-{episode_chunk:03d}/{video_key}/episode_{episode_index:06d}.mp4",
  "features": {
    "action": {
      "dtype": "float32",
      "shape": [6],
      "names": ["main_shoulder_pan", "main_shoulder_lift", "main_elbow_flex",
               "main_wrist_flex", "main_wrist_roll", "main_gripper"]
    },
    "observation.state": { /* 相同结构 */ },
    "observation.images.laptop": {
      "dtype": "video",
      "shape": [480, 640, 3]
    },
    "observation.images.phone": {
      "dtype": "video",
      "shape": [480, 640, 3]
    }
  }
}
```

### 2.3 功能复杂度评估

#### 2.3.1 必需功能 (核心)
- ✅ 数据集加载和解析
- ✅ Episode数据提取和格式转换
- ✅ 视频路径解析和服务
- ✅ Web路由和API端点
- ✅ HTML模板渲染

#### 2.3.2 可选功能 (简化目标)
- ⚠️ HuggingFace Hub集成 → 移除 (专注本地数据)
- ⚠️ 复杂的数据验证 → 简化
- ⚠️ 多数据集支持 → 单一数据集
- ⚠️ 高级配置选项 → 基础配置

#### 2.3.3 冗余功能 (移除目标)
- ❌ plot_utils.py (深度学习模型分析工具)
- ❌ 训练相关的数据处理逻辑
- ❌ 复杂的缓存和优化机制
- ❌ 多环境配置支持

## 3. 最小化架构设计

### 3.1 整体架构原则

#### 3.1.1 设计原则
- **单一职责**: 每个模块只负责一个核心功能
- **最小依赖**: 仅保留可视化必需的依赖项
- **本地优先**: 专门针对本地数据集优化
- **易于维护**: 清晰的模块边界和简单的接口

#### 3.1.2 架构分层
```
┌─────────────────────────────────────┐
│           用户界面层                 │  Browser (HTML/CSS/JS)
├─────────────────────────────────────┤
│           Web应用层                  │  Flask Routes & Templates
├─────────────────────────────────────┤
│           核心业务层                 │  Data Processing & Logic
├─────────────────────────────────────┤
│           数据访问层                 │  File System & Data Loading
└─────────────────────────────────────┘
```

### 3.2 目录结构设计

```
lerobot_data/
├── core/                           # 核心业务模块
│   ├── __init__.py
│   ├── data_loader.py              # 数据加载器 + IterableNamespace
│   ├── config.py                   # 配置管理 + 路径模板
│   └── video_handler.py            # 视频路径处理和验证
├── web/                            # Web应用模块
│   ├── __init__.py
│   ├── app.py                      # Flask应用 + 路由 + 日志
│   └── static/                     # 静态资源 (可选)
│       └── favicon.ico
├── templates/                      # Jinja2模板
│   ├── base.html                   # 基础模板
│   ├── home.html                   # 首页模板
│   └── episode.html                # Episode详情页模板
├── main.py                         # 应用启动入口
├── requirements.txt                # Python依赖声明
├── config.yaml                     # 应用配置文件
└── README.md                       # 项目说明文档
```

### 3.3 核心模块详细设计

#### 3.3.1 core/data_loader.py
```python
"""
数据加载器模块
功能: 统一处理数据集加载、Episode数据提取、CSV格式转换
"""

from pathlib import Path
from types import SimpleNamespace
from typing import Any, Dict, List, Optional, Iterator
import json
import pandas as pd
import numpy as np
from io import StringIO
import csv

class IterableNamespace(SimpleNamespace):
    """
    支持迭代的命名空间对象
    提供字典和点号双重访问方式
    """
    def __init__(self, dictionary: Dict[str, Any] = None, **kwargs):
        super().__init__(**kwargs)
        if dictionary is not None:
            for key, value in dictionary.items():
                if isinstance(value, dict):
                    setattr(self, key, IterableNamespace(value))
                else:
                    setattr(self, key, value)

    def __iter__(self) -> Iterator[str]:
        return iter(vars(self))

    def __getitem__(self, key: str) -> Any:
        return vars(self)[key]

    def items(self):
        return vars(self).items()

    def keys(self):
        return vars(self).keys()

    def values(self):
        return vars(self).values()

class LocalDatasetLoader:
    """
    本地数据集加载器
    专门处理grasp_dataset格式的数据
    """
    def __init__(self, dataset_path: str):
        self.dataset_path = Path(dataset_path)
        self.info = self._load_info()
        self.episodes_list = self._load_episodes()

    def _load_info(self) -> IterableNamespace:
        """加载数据集基本信息"""
        info_path = self.dataset_path / "meta" / "info.json"
        with open(info_path, 'r') as f:
            info_data = json.load(f)
        return IterableNamespace(info_data)

    def _load_episodes(self) -> List[int]:
        """加载episode列表"""
        return list(range(self.info.total_episodes))

    def load_episode_data(self, episode_index: int) -> str:
        """
        加载单个episode的时间序列数据，返回CSV格式字符串
        供前端Dygraphs使用
        """
        # 构建数据文件路径
        episode_chunk = episode_index // self.info.chunks_size
        data_path = self.dataset_path / self.info.data_path.format(
            episode_chunk=episode_chunk,
            episode_index=episode_index
        )

        # 读取parquet文件
        df = pd.read_parquet(data_path)

        # 选择数值型列用于可视化
        numeric_columns = []
        header = ["timestamp"]

        for col_name, feature_info in self.info.features.items():
            if feature_info["dtype"] in ["float32", "int32"] and col_name != "timestamp":
                shape = feature_info["shape"]
                if len(shape) == 1:  # 只处理一维数据
                    if "names" in feature_info and feature_info["names"]:
                        col_names = feature_info["names"]
                        header.extend(col_names)
                        numeric_columns.append(col_name)

        # 构建CSV数据
        selected_columns = ["timestamp"] + numeric_columns
        data_subset = df[selected_columns]

        # 转换为CSV字符串
        csv_buffer = StringIO()
        csv_writer = csv.writer(csv_buffer)
        csv_writer.writerow(header)

        # 写入数据行
        for _, row in data_subset.iterrows():
            csv_row = [row["timestamp"]]
            for col in numeric_columns:
                if isinstance(row[col], np.ndarray):
                    csv_row.extend(row[col].tolist())
                else:
                    csv_row.append(row[col])
            csv_writer.writerow(csv_row)

        return csv_buffer.getvalue()

    def get_episode_info(self, episode_index: int) -> Dict[str, Any]:
        """获取episode基本信息"""
        return {
            "episode_id": episode_index,
            "total_episodes": self.info.total_episodes,
            "fps": self.info.fps
        }
```

#### 3.3.2 core/config.py
```python
"""
配置管理模块
功能: 路径模板、应用配置、常量定义
"""

from pathlib import Path
import yaml
from typing import Dict, Any

class DatasetConfig:
    """数据集配置管理"""

    # 路径模板 (来自info.json)
    DATA_PATH_TEMPLATE = "data/chunk-{episode_chunk:03d}/episode_{episode_index:06d}.parquet"
    VIDEO_PATH_TEMPLATE = "videos/chunk-{episode_chunk:03d}/{video_key}/episode_{episode_index:06d}.mp4"

    # 元数据路径
    INFO_PATH = "meta/info.json"
    EPISODES_PATH = "meta/episodes.jsonl"
    STATS_PATH = "meta/episodes_stats.jsonl"

    # 默认设置
    DEFAULT_CHUNK_SIZE = 1000
    DEFAULT_FPS = 30

    def __init__(self, dataset_path: str):
        self.dataset_path = Path(dataset_path)

    def get_data_path(self, episode_index: int, chunk_size: int = None) -> Path:
        """获取数据文件路径"""
        chunk_size = chunk_size or self.DEFAULT_CHUNK_SIZE
        episode_chunk = episode_index // chunk_size
        return self.dataset_path / self.DATA_PATH_TEMPLATE.format(
            episode_chunk=episode_chunk, episode_index=episode_index
        )

    def get_video_path(self, episode_index: int, video_key: str, chunk_size: int = None) -> Path:
        """获取视频文件路径"""
        chunk_size = chunk_size or self.DEFAULT_CHUNK_SIZE
        episode_chunk = episode_index // chunk_size
        return self.dataset_path / self.VIDEO_PATH_TEMPLATE.format(
            episode_chunk=episode_chunk, video_key=video_key, episode_index=episode_index
        )

class AppConfig:
    """应用配置管理"""

    def __init__(self, config_file: str = "config.yaml"):
        self.config_file = Path(config_file)
        self.config = self._load_config()

    def _load_config(self) -> Dict[str, Any]:
        """加载配置文件"""
        if self.config_file.exists():
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f) or {}
        return self._get_default_config()

    def _get_default_config(self) -> Dict[str, Any]:
        """默认配置"""
        return {
            "app": {
                "host": "127.0.0.1",
                "port": 9090,
                "debug": False
            },
            "dataset": {
                "path": "/home/chenqingyu/robot/new_lerobot/grasp_dataset",
                "cache_enabled": False
            },
            "ui": {
                "episodes_per_page": 50,
                "default_video_keys": ["laptop", "phone"]
            }
        }

    def get(self, key: str, default=None):
        """获取配置值 (支持点号路径)"""
        keys = key.split('.')
        value = self.config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        return value
```

#### 3.3.3 core/video_handler.py
```python
"""
视频处理模块
功能: 视频路径解析、文件验证、播放器配置
"""

from pathlib import Path
from typing import Dict, List, Optional
from .config import DatasetConfig

class VideoHandler:
    """视频文件处理器"""

    SUPPORTED_FORMATS = ['.mp4', '.webm', '.avi']
    DEFAULT_VIDEO_KEYS = ['laptop', 'phone']

    def __init__(self, dataset_config: DatasetConfig):
        self.config = dataset_config

    def get_video_paths(self, episode_index: int, video_keys: List[str] = None) -> Dict[str, str]:
        """
        获取episode的视频文件路径
        返回格式: {"laptop": "path/to/laptop/video.mp4", "phone": "path/to/phone/video.mp4"}
        """
        video_keys = video_keys or self.DEFAULT_VIDEO_KEYS
        video_paths = {}

        for video_key in video_keys:
            video_path = self.config.get_video_path(episode_index, video_key)
            if video_path.exists():
                # 转换为Web可访问的相对路径
                relative_path = video_path.relative_to(self.config.dataset_path)
                video_paths[video_key] = str(relative_path)

        return video_paths

    def validate_video_file(self, video_path: Path) -> bool:
        """验证视频文件是否有效"""
        if not video_path.exists():
            return False

        if video_path.suffix.lower() not in self.SUPPORTED_FORMATS:
            return False

        # 检查文件大小 (避免空文件)
        if video_path.stat().st_size == 0:
            return False

        return True

    def get_video_info(self, episode_index: int) -> Dict[str, Dict]:
        """
        获取episode视频信息 (用于前端播放器配置)
        """
        video_paths = self.get_video_paths(episode_index)
        video_info = []

        for video_key, relative_path in video_paths.items():
            video_info.append({
                "key": video_key,
                "path": relative_path,
                "type": "video/mp4"
            })

        return video_info
```

## 4. 实施计划与步骤

### 4.1 实施阶段划分

#### 4.1.1 阶段一: 核心模块开发 (Day 1-2)
**目标**: 完成数据加载和配置管理的核心功能

**任务清单**:
- [ ] 创建项目目录结构
- [ ] 实现 `core/data_loader.py`
  - [ ] IterableNamespace 类
  - [ ] LocalDatasetLoader 类
  - [ ] CSV数据转换功能
- [ ] 实现 `core/config.py`
  - [ ] DatasetConfig 类
  - [ ] AppConfig 类
  - [ ] 路径模板处理
- [ ] 实现 `core/video_handler.py`
  - [ ] 视频路径解析
  - [ ] 文件验证逻辑
- [ ] 单元测试编写和验证

**验收标准**:
```python
# 测试数据加载
loader = LocalDatasetLoader("/home/chenqingyu/robot/new_lerobot/grasp_dataset")
episode_data = loader.load_episode_data(0)
assert isinstance(episode_data, str)  # CSV格式
assert "timestamp" in episode_data

# 测试配置管理
config = DatasetConfig("/home/chenqingyu/robot/new_lerobot/grasp_dataset")
data_path = config.get_data_path(0)
assert data_path.exists()

# 测试视频处理
video_handler = VideoHandler(config)
video_info = video_handler.get_video_info(0)
assert len(video_info) > 0
```

#### 4.1.2 阶段二: Web应用开发 (Day 3-5)
**目标**: 完成Flask应用和前端界面

**任务清单**:
- [ ] 实现 `web/app.py`
  - [ ] Flask应用工厂
  - [ ] 路由定义
  - [ ] 错误处理
  - [ ] 日志配置
- [ ] 创建HTML模板
  - [ ] 从原项目提取并适配模板
  - [ ] 简化前端依赖
  - [ ] 调整Alpine.js交互逻辑
- [ ] 实现 `main.py` 启动脚本
- [ ] 配置文件创建

**核心路由设计**:
```python
# 主要路由
@app.route('/')                           # 首页
@app.route('/episode/<int:episode_id>')   # Episode详情页
@app.route('/api/episode/<int:episode_id>/data')  # Episode数据API
@app.route('/api/episode/<int:episode_id>/videos') # 视频信息API
@app.route('/static/<path:filename>')     # 静态文件服务
```

**验收标准**:
- [ ] Web应用可以正常启动
- [ ] 首页显示Episode列表
- [ ] Episode详情页显示视频和图表
- [ ] API端点返回正确的数据格式
- [ ] 前端JavaScript无错误

#### 4.1.3 阶段三: 集成测试与优化 (Day 6)
**目标**: 端到端功能测试和性能优化

**任务清单**:
- [ ] 端到端功能测试
  - [ ] 数据加载完整性测试
  - [ ] 视频播放功能测试
  - [ ] 图表渲染功能测试
  - [ ] 多Episode导航测试
- [ ] 性能优化
  - [ ] 数据加载性能测试
  - [ ] 内存使用优化
  - [ ] Web响应时间优化
- [ ] 错误处理完善
- [ ] 文档完善

**验收标准**:
- [ ] 所有701个Episode都能正常访问
- [ ] 视频播放同步正常
- [ ] 时间序列图表显示正确
- [ ] Episode切换响应速度 < 2秒
- [ ] 内存使用稳定，无内存泄漏

### 4.2 关键实施细节

#### 4.2.1 数据提取策略
```python
# 从原项目提取的核心函数模板
def extract_episode_data(dataset, episode_index):
    """
    基于原项目 get_episode_data 函数的简化版本
    原文件: lerobot/scripts/visualize_dataset_html.py:232-299
    """
    # 1. 选择数值型特征列
    selected_columns = []
    for col, feature in dataset.features.items():
        if feature["dtype"] in ["float32", "int32"] and col != "timestamp":
            if len(feature["shape"]) == 1:  # 只处理一维数据
                selected_columns.append(col)

    # 2. 构建CSV表头
    header = ["timestamp"]
    for col in selected_columns:
        if "names" in dataset.features[col]:
            header.extend(dataset.features[col]["names"])

    # 3. 读取并转换数据
    # ... 数据处理逻辑
```

#### 4.2.2 模板迁移策略
```html
<!-- 从原项目模板提取的核心结构 -->
<!-- 原文件: lerobot/templates/visualize_dataset_template.html -->

<!-- 保留的核心元素 -->
<div x-data="createAlpineData()">
    <!-- Episode导航侧边栏 -->
    <div class="sidebar">
        <!-- Episode列表 -->
    </div>

    <!-- 主内容区域 -->
    <div class="main-content">
        <!-- 视频播放器 -->
        <div class="video-container">
            <!-- 多视频同步播放 -->
        </div>

        <!-- 数据图表 -->
        <div class="chart-container">
            <!-- Dygraphs时间序列图表 -->
        </div>
    </div>
</div>
```

#### 4.2.3 依赖简化策略
```python
# requirements.txt 最小依赖集合
flask>=2.0.0
pandas>=1.3.0
numpy>=1.21.0
PyYAML>=6.0
pyarrow>=5.0.0  # for parquet support

# 移除的依赖 (原项目中的)
# torch>=1.13.0          # 深度学习框架 - 不需要
# huggingface_hub>=0.15.0 # HF Hub集成 - 不需要
# datasets>=2.12.0       # HF datasets - 不需要
# matplotlib>=3.5.0      # 绘图库 - 前端处理
# rerun-sdk>=0.8.0       # 3D可视化 - 不需要
```

### 4.3 风险控制与应对

#### 4.3.1 技术风险
| 风险项 | 影响程度 | 应对策略 |
|--------|----------|----------|
| 数据格式不兼容 | 高 | 提前验证本地数据集格式，准备格式转换工具 |
| 视频播放问题 | 中 | 测试多种浏览器，准备视频格式转换 |
| 性能问题 | 中 | 实现数据分页加载，优化查询逻辑 |
| 前端兼容性 | 低 | 使用成熟的前端库，测试主流浏览器 |

#### 4.3.2 实施风险
| 风险项 | 影响程度 | 应对策略 |
|--------|----------|----------|
| 开发进度延迟 | 中 | 分阶段实施，优先核心功能 |
| 功能需求变更 | 低 | 模块化设计，便于扩展和修改 |
| 测试覆盖不足 | 中 | 每个阶段都有明确的验收标准 |

### 4.4 里程碑与交付物

#### 4.4.1 阶段一交付物 (Day 2)
- [ ] `core/` 模块完整代码
- [ ] 核心功能单元测试
- [ ] 数据加载验证报告

#### 4.4.2 阶段二交付物 (Day 5)
- [ ] 完整的Web应用
- [ ] HTML模板文件
- [ ] 配置文件和启动脚本
- [ ] 功能演示视频

#### 4.4.3 阶段三交付物 (Day 6)
- [ ] 完整的lerobot_visualizer项目
- [ ] 测试报告和性能基准
- [ ] 用户使用文档
- [ ] 部署和配置指南

## 5. 技术规范与配置

### 5.1 系统需求

#### 5.1.1 运行环境
```yaml
# 最低系统要求
操作系统: Linux/macOS/Windows
Python版本: >= 3.8
内存: >= 4GB
磁盘空间: >= 2GB (用于依赖和缓存)
网络: 可选 (仅用于CDN资源)
```

#### 5.1.2 Python依赖管理
```ini
# requirements.txt 详细版本
Flask==2.3.3
pandas==2.0.3
numpy==1.24.3
PyYAML==6.0.1
pyarrow==12.0.1

# 开发依赖 (可选)
pytest==7.4.0
pytest-cov==4.1.0
black==23.7.0
flake8==6.0.0
```

#### 5.1.3 前端依赖 (CDN)
```html
<!-- 核心JavaScript库 (通过CDN引入，无需本地安装) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/alpinejs/3.13.5/cdn.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dygraphs@2.2.1/dist/dygraph.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<!-- 可选: 本地化处理 -->
<!-- 如需离线使用，可下载到 web/static/js/ 目录 -->
```

### 5.2 配置文件规范

#### 5.2.1 config.yaml 完整配置
```yaml
# 应用配置
app:
  host: "127.0.0.1"        # 绑定地址
  port: 9090               # 端口号
  debug: false             # 调试模式
  secret_key: "lerobot-visualizer-2025"

# 数据集配置
dataset:
  path: "/home/chenqingyu/robot/new_lerobot/grasp_dataset"
  cache_enabled: false     # 数据缓存开关
  max_episodes: 701        # 最大episode数量
  chunk_size: 1000         # chunk大小

# UI配置
ui:
  episodes_per_page: 50    # 每页显示的episode数量
  default_video_keys:      # 默认视频源
    - "laptop"
    - "phone"
  chart_height: 400        # 图表高度(像素)
  video_width: 640         # 视频播放器宽度

# 日志配置
logging:
  level: "INFO"            # 日志级别: DEBUG/INFO/WARNING/ERROR
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  file: "logs/app.log"     # 日志文件路径 (可选)

# 性能配置
performance:
  max_csv_size: 10485760   # 最大CSV文件大小 (10MB)
  request_timeout: 30      # 请求超时时间(秒)
  static_cache_timeout: 3600  # 静态文件缓存时间(秒)
```

#### 5.2.2 环境变量支持
```bash
# .env 文件支持 (可选)
LEROBOT_DATASET_PATH="/home/chenqingyu/robot/new_lerobot/grasp_dataset"
LEROBOT_HOST="0.0.0.0"
LEROBOT_PORT="8080"
LEROBOT_DEBUG="false"

# 使用方式
export LEROBOT_DATASET_PATH="/path/to/dataset"
python main.py
```

### 5.3 API接口规范

#### 5.3.1 RESTful API设计
```python
# GET /api/dataset/info - 获取数据集基本信息
{
    "total_episodes": 701,
    "total_frames": 238279,
    "fps": 30,
    "robot_type": "koch",
    "features": {
        "action": {...},
        "observation.state": {...}
    }
}

# GET /api/episodes - 获取episode列表
{
    "episodes": [
        {"id": 0, "frames": 340, "duration": 11.33},
        {"id": 1, "frames": 298, "duration": 9.93},
        # ...
    ],
    "total": 701,
    "page": 1,
    "per_page": 50
}

# GET /api/episode/{id}/data - 获取episode时间序列数据
# 返回: CSV格式字符串
timestamp,main_shoulder_pan,main_shoulder_lift,main_elbow_flex,main_wrist_flex,main_wrist_roll,main_gripper
0.0,0.123,-0.456,0.789,-0.234,0.567,-0.890
0.033,0.124,-0.455,0.788,-0.235,0.568,-0.889
...

# GET /api/episode/{id}/videos - 获取episode视频信息
{
    "videos": [
        {"key": "laptop", "path": "videos/chunk-000/laptop/episode_000000.mp4", "type": "video/mp4"},
        {"key": "phone", "path": "videos/chunk-000/phone/episode_000000.mp4", "type": "video/mp4"}
    ]
}
```

#### 5.3.2 错误处理规范
```python
# 标准错误响应格式
{
    "error": {
        "code": "EPISODE_NOT_FOUND",
        "message": "Episode 999 not found",
        "details": "Valid episode range: 0-700"
    }
}

# HTTP状态码使用
200 OK          # 正常响应
404 Not Found   # Episode不存在
400 Bad Request # 参数错误
500 Internal Server Error  # 服务器内部错误
```

### 5.4 性能优化配置

#### 5.4.1 数据加载优化
```python
# 数据加载缓存策略
class DataCache:
    """数据缓存管理器"""

    def __init__(self, max_size: int = 100):
        self.cache = {}
        self.max_size = max_size
        self.access_order = []

    def get_episode_data(self, episode_id: int) -> str:
        """获取episode数据，带LRU缓存"""
        if episode_id in self.cache:
            self._update_access(episode_id)
            return self.cache[episode_id]

        # 加载数据
        data = self._load_episode_data(episode_id)
        self._cache_data(episode_id, data)
        return data
```

#### 5.4.2 Web服务优化
```python
# Flask优化配置
app.config.update({
    'SEND_FILE_MAX_AGE_DEFAULT': 3600,    # 静态文件缓存
    'MAX_CONTENT_LENGTH': 16 * 1024 * 1024,  # 最大请求大小16MB
    'JSON_SORT_KEYS': False,              # 不排序JSON键
})

# Gzip压缩中间件
from flask_compress import Compress
Compress(app)
```

### 5.5 安全配置

#### 5.5.1 基础安全设置
```python
# 安全配置
app.config.update({
    'SECRET_KEY': os.environ.get('SECRET_KEY', 'dev-key-change-in-production'),
    'WTF_CSRF_ENABLED': False,  # API应用，禁用CSRF
    'JSON_SORT_KEYS': False,
})

# 请求限制
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["100 per hour"]  # 每小时100次请求
)
```

#### 5.5.2 文件访问安全
```python
# 安全的文件路径处理
def safe_path_join(base_path: Path, *paths: str) -> Path:
    """安全的路径拼接，防止目录遍历攻击"""
    result_path = base_path
    for path in paths:
        # 清理路径组件
        clean_path = Path(path).name  # 只取文件名，去除路径
        result_path = result_path / clean_path

    # 确保结果路径在基础路径内
    if not str(result_path.resolve()).startswith(str(base_path.resolve())):
        raise ValueError("Path traversal attempt detected")

    return result_path
```

### 5.6 部署配置

#### 5.6.1 开发环境启动
```bash
# 开发模式启动
python main.py --debug --host 127.0.0.1 --port 9090

# 或使用配置文件
python main.py --config config.yaml
```

#### 5.6.2 生产环境配置
```bash
# 使用Gunicorn部署
pip install gunicorn

# 启动命令
gunicorn -w 4 -b 0.0.0.0:9090 --timeout 30 --max-requests 1000 main:app

# systemd服务配置 (可选)
[Unit]
Description=LeRobot Visualizer
After=network.target

[Service]
Type=exec
User=www-data
Group=www-data
WorkingDirectory=/path/to/lerobot_visualizer
ExecStart=/usr/local/bin/gunicorn -w 4 -b 127.0.0.1:9090 main:app
Restart=always

[Install]
WantedBy=multi-user.target
```

#### 5.6.3 Nginx反向代理配置
```nginx
# /etc/nginx/sites-available/lerobot-visualizer
server {
    listen 80;
    server_name your-domain.com;

    client_max_body_size 50M;

    # 静态文件直接服务
    location /static/ {
        alias /path/to/lerobot_visualizer/web/static/;
        expires 1h;
    }

    # 视频文件直接服务
    location /videos/ {
        alias /home/chenqingyu/robot/new_lerobot/grasp_dataset/videos/;
        expires 1h;
    }

    # 代理到Flask应用
    location / {
        proxy_pass http://127.0.0.1:9090;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

## 6. 测试验证方案

### 6.1 测试策略

#### 6.1.1 测试层级划分
```
┌─────────────────────────────────────┐
│           端到端测试                 │  Web UI + 用户交互流程
├─────────────────────────────────────┤
│           集成测试                   │  模块间协作 + API接口
├─────────────────────────────────────┤
│           单元测试                   │  单个函数/类功能验证
├─────────────────────────────────────┤
│           数据验证测试               │  数据集格式和完整性
└─────────────────────────────────────┘
```

#### 6.1.2 测试覆盖目标
- **代码覆盖率**: >= 80%
- **功能覆盖率**: >= 95% (核心功能)
- **浏览器兼容性**: Chrome, Firefox, Safari, Edge
- **性能基准**: 响应时间 < 2秒, 内存使用 < 500MB

### 6.2 单元测试

#### 6.2.1 核心模块测试
```python
# tests/test_data_loader.py
import pytest
from pathlib import Path
from core.data_loader import LocalDatasetLoader, IterableNamespace

class TestLocalDatasetLoader:
    @pytest.fixture
    def dataset_loader(self):
        return LocalDatasetLoader("/home/chenqingyu/robot/new_lerobot/grasp_dataset")

    def test_load_info(self, dataset_loader):
        """测试数据集信息加载"""
        assert dataset_loader.info.total_episodes == 701
        assert dataset_loader.info.total_frames == 238279
        assert dataset_loader.info.fps == 30
        assert dataset_loader.info.robot_type == "koch"

    def test_load_episodes_list(self, dataset_loader):
        """测试episode列表加载"""
        episodes = dataset_loader.episodes_list
        assert len(episodes) == 701
        assert episodes[0] == 0
        assert episodes[-1] == 700

    def test_load_episode_data_format(self, dataset_loader):
        """测试episode数据格式"""
        csv_data = dataset_loader.load_episode_data(0)
        assert isinstance(csv_data, str)
        assert "timestamp" in csv_data.split('\n')[0]
        assert len(csv_data.split('\n')) > 1  # 至少有表头和数据行

    def test_invalid_episode_handling(self, dataset_loader):
        """测试无效episode处理"""
        with pytest.raises(FileNotFoundError):
            dataset_loader.load_episode_data(999)

class TestIterableNamespace:
    def test_dict_access(self):
        """测试字典式访问"""
        ns = IterableNamespace({"key": "value", "nested": {"inner": "data"}})
        assert ns["key"] == "value"
        assert ns["nested"]["inner"] == "data"

    def test_attr_access(self):
        """测试属性式访问"""
        ns = IterableNamespace({"key": "value", "nested": {"inner": "data"}})
        assert ns.key == "value"
        assert ns.nested.inner == "data"

    def test_iteration(self):
        """测试迭代功能"""
        ns = IterableNamespace({"a": 1, "b": 2, "c": 3})
        keys = list(ns)
        assert sorted(keys) == ["a", "b", "c"]
```

#### 6.2.2 配置管理测试
```python
# tests/test_config.py
import pytest
from pathlib import Path
from core.config import DatasetConfig, AppConfig

class TestDatasetConfig:
    @pytest.fixture
    def config(self):
        return DatasetConfig("/home/chenqingyu/robot/new_lerobot/grasp_dataset")

    def test_data_path_generation(self, config):
        """测试数据路径生成"""
        path = config.get_data_path(0)
        expected = Path("/home/chenqingyu/robot/new_lerobot/grasp_dataset/data/chunk-000/episode_000000.parquet")
        assert path == expected

    def test_video_path_generation(self, config):
        """测试视频路径生成"""
        path = config.get_video_path(0, "laptop")
        expected = Path("/home/chenqingyu/robot/new_lerobot/grasp_dataset/videos/chunk-000/laptop/episode_000000.mp4")
        assert path == expected

    def test_chunk_calculation(self, config):
        """测试chunk计算"""
        # Episode 0 -> chunk 0
        assert config.get_data_path(0).parts[-2] == "chunk-000"
        # Episode 1000 -> chunk 1
        assert config.get_data_path(1000).parts[-2] == "chunk-001"

class TestAppConfig:
    def test_default_config_loading(self):
        """测试默认配置加载"""
        config = AppConfig("nonexistent.yaml")
        assert config.get("app.host") == "127.0.0.1"
        assert config.get("app.port") == 9090
        assert config.get("dataset.path") == "/home/chenqingyu/robot/new_lerobot/grasp_dataset"

    def test_nested_key_access(self):
        """测试嵌套键访问"""
        config = AppConfig("nonexistent.yaml")
        assert config.get("ui.episodes_per_page") == 50
        assert config.get("ui.default_video_keys") == ["laptop", "phone"]

    def test_missing_key_default(self):
        """测试缺失键的默认值"""
        config = AppConfig("nonexistent.yaml")
        assert config.get("nonexistent.key", "default") == "default"
```

#### 6.2.3 视频处理测试
```python
# tests/test_video_handler.py
import pytest
from pathlib import Path
from core.config import DatasetConfig
from core.video_handler import VideoHandler

class TestVideoHandler:
    @pytest.fixture
    def video_handler(self):
        config = DatasetConfig("/home/chenqingyu/robot/new_lerobot/grasp_dataset")
        return VideoHandler(config)

    def test_get_video_paths(self, video_handler):
        """测试视频路径获取"""
        video_paths = video_handler.get_video_paths(0)
        assert "laptop" in video_paths
        assert "phone" in video_paths
        assert video_paths["laptop"].endswith("episode_000000.mp4")

    def test_validate_existing_video(self, video_handler):
        """测试现有视频文件验证"""
        video_path = Path("/home/chenqingyu/robot/new_lerobot/grasp_dataset/videos/chunk-000/laptop/episode_000000.mp4")
        if video_path.exists():
            assert video_handler.validate_video_file(video_path) == True

    def test_validate_nonexistent_video(self, video_handler):
        """测试不存在视频文件验证"""
        video_path = Path("/nonexistent/path/video.mp4")
        assert video_handler.validate_video_file(video_path) == False

    def test_get_video_info(self, video_handler):
        """测试视频信息获取"""
        video_info = video_handler.get_video_info(0)
        assert len(video_info) >= 0  # 可能没有视频文件
        if video_info:
            assert "key" in video_info[0]
            assert "path" in video_info[0]
            assert "type" in video_info[0]
```

### 6.3 集成测试

#### 6.3.1 API接口测试
```python
# tests/test_api.py
import pytest
import json
from web.app import create_app

class TestAPIEndpoints:
    @pytest.fixture
    def client(self):
        app = create_app("/home/chenqingyu/robot/new_lerobot/grasp_dataset")
        app.config['TESTING'] = True
        with app.test_client() as client:
            yield client

    def test_dataset_info_api(self, client):
        """测试数据集信息API"""
        response = client.get('/api/dataset/info')
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['total_episodes'] == 701
        assert data['robot_type'] == 'koch'

    def test_episodes_list_api(self, client):
        """测试episodes列表API"""
        response = client.get('/api/episodes')
        assert response.status_code == 200
        data = json.loads(response.data)
        assert 'episodes' in data
        assert data['total'] == 701

    def test_episode_data_api(self, client):
        """测试episode数据API"""
        response = client.get('/api/episode/0/data')
        assert response.status_code == 200
        csv_data = response.data.decode('utf-8')
        assert 'timestamp' in csv_data.split('\n')[0]

    def test_episode_videos_api(self, client):
        """测试episode视频API"""
        response = client.get('/api/episode/0/videos')
        assert response.status_code == 200
        data = json.loads(response.data)
        assert 'videos' in data

    def test_invalid_episode_api(self, client):
        """测试无效episode处理"""
        response = client.get('/api/episode/999/data')
        assert response.status_code == 404
        data = json.loads(response.data)
        assert 'error' in data
```

#### 6.3.2 Web界面测试
```python
# tests/test_web_pages.py
import pytest
from web.app import create_app

class TestWebPages:
    @pytest.fixture
    def client(self):
        app = create_app("/home/chenqingyu/robot/new_lerobot/grasp_dataset")
        app.config['TESTING'] = True
        with app.test_client() as client:
            yield client

    def test_home_page(self, client):
        """测试首页"""
        response = client.get('/')
        assert response.status_code == 200
        assert b'Episode' in response.data

    def test_episode_page(self, client):
        """测试episode详情页"""
        response = client.get('/episode/0')
        assert response.status_code == 200
        assert b'episode_0' in response.data.lower() or b'episode 0' in response.data.lower()

    def test_invalid_episode_page(self, client):
        """测试无效episode页面"""
        response = client.get('/episode/999')
        assert response.status_code in [404, 500]  # 错误处理
```

### 6.4 端到端测试

#### 6.4.1 用户交互流程测试
```python
# tests/test_e2e.py (使用 Selenium)
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

class TestE2EUserFlow:
    @pytest.fixture(scope="class")
    def driver(self):
        options = webdriver.ChromeOptions()
        options.add_argument("--headless")  # 无头模式测试
        driver = webdriver.Chrome(options=options)
        driver.get("http://localhost:9090")
        yield driver
        driver.quit()

    def test_homepage_load(self, driver):
        """测试首页加载"""
        wait = WebDriverWait(driver, 10)
        episodes_list = wait.until(EC.presence_of_element_located((By.CLASS_NAME, "episodes-list")))
        assert episodes_list is not None

    def test_episode_navigation(self, driver):
        """测试episode导航"""
        # 点击第一个episode
        first_episode = driver.find_element(By.XPATH, "//a[contains(text(), 'Episode 0')]")
        first_episode.click()

        # 等待页面加载
        wait = WebDriverWait(driver, 10)
        video_container = wait.until(EC.presence_of_element_located((By.CLASS_NAME, "video-container")))
        assert video_container is not None

    def test_video_playback(self, driver):
        """测试视频播放功能"""
        driver.get("http://localhost:9090/episode/0")

        wait = WebDriverWait(driver, 10)
        video_elements = wait.until(EC.presence_of_all_elements_located((By.TAG_NAME, "video")))

        # 检查视频元素存在
        assert len(video_elements) >= 1

        # 检查视频源设置
        for video in video_elements:
            src = video.get_attribute("src")
            assert src is not None and src != ""

    def test_chart_rendering(self, driver):
        """测试图表渲染"""
        driver.get("http://localhost:9090/episode/0")

        wait = WebDriverWait(driver, 15)  # 图表加载可能需要更多时间
        chart_container = wait.until(EC.presence_of_element_located((By.CLASS_NAME, "chart-container")))

        # 检查图表元素
        dygraph_element = chart_container.find_element(By.CSS_SELECTOR, ".dygraph-legend")
        assert dygraph_element is not None
```

### 6.5 性能测试

#### 6.5.1 负载测试
```python
# tests/test_performance.py
import time
import requests
import pytest
from concurrent.futures import ThreadPoolExecutor, as_completed

class TestPerformance:
    BASE_URL = "http://localhost:9090"

    def test_response_time_single_request(self):
        """测试单次请求响应时间"""
        start_time = time.time()
        response = requests.get(f"{self.BASE_URL}/api/episode/0/data")
        end_time = time.time()

        assert response.status_code == 200
        assert (end_time - start_time) < 2.0  # 2秒内响应

    def test_concurrent_requests(self):
        """测试并发请求处理"""
        def make_request(episode_id):
            response = requests.get(f"{self.BASE_URL}/api/episode/{episode_id}/data")
            return response.status_code, response.elapsed.total_seconds()

        # 并发请求10个不同的episode
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(make_request, i) for i in range(10)]
            results = [future.result() for future in as_completed(futures)]

        # 检查所有请求都成功
        for status_code, duration in results:
            assert status_code == 200
            assert duration < 5.0  # 并发情况下5秒内响应

    def test_memory_usage(self):
        """测试内存使用情况"""
        import psutil
        import os

        # 获取当前进程内存使用
        process = psutil.Process(os.getpid())
        memory_before = process.memory_info().rss / 1024 / 1024  # MB

        # 执行多次数据加载
        for i in range(50):
            response = requests.get(f"{self.BASE_URL}/api/episode/{i % 10}/data")
            assert response.status_code == 200

        memory_after = process.memory_info().rss / 1024 / 1024  # MB
        memory_increase = memory_after - memory_before

        # 内存增长不应超过100MB
        assert memory_increase < 100, f"Memory increased by {memory_increase}MB"
```

### 6.6 数据验证测试

#### 6.6.1 数据集完整性验证
```python
# tests/test_data_integrity.py
import pytest
from pathlib import Path
import pandas as pd
import json

class TestDataIntegrity:
    @pytest.fixture
    def dataset_path(self):
        return Path("/home/chenqingyu/robot/new_lerobot/grasp_dataset")

    def test_dataset_structure(self, dataset_path):
        """测试数据集目录结构"""
        assert (dataset_path / "meta" / "info.json").exists()
        assert (dataset_path / "meta" / "episodes.jsonl").exists()
        assert (dataset_path / "data").exists()
        assert (dataset_path / "videos").exists()

    def test_info_json_validity(self, dataset_path):
        """测试info.json有效性"""
        info_path = dataset_path / "meta" / "info.json"
        with open(info_path, 'r') as f:
            info = json.load(f)

        required_fields = ["total_episodes", "total_frames", "fps", "features"]
        for field in required_fields:
            assert field in info, f"Missing required field: {field}"

    def test_episode_data_files(self, dataset_path):
        """测试episode数据文件完整性"""
        info_path = dataset_path / "meta" / "info.json"
        with open(info_path, 'r') as f:
            info = json.load(f)

        # 随机检查10个episode的数据文件
        import random
        episode_samples = random.sample(range(info["total_episodes"]), min(10, info["total_episodes"]))

        for episode_id in episode_samples:
            episode_chunk = episode_id // info.get("chunks_size", 1000)
            data_file = dataset_path / f"data/chunk-{episode_chunk:03d}/episode_{episode_id:06d}.parquet"

            assert data_file.exists(), f"Missing data file for episode {episode_id}"

            # 检查parquet文件可读性
            df = pd.read_parquet(data_file)
            assert len(df) > 0, f"Empty data file for episode {episode_id}"
            assert "timestamp" in df.columns, f"Missing timestamp in episode {episode_id}"

    def test_video_files_existence(self, dataset_path):
        """测试视频文件存在性"""
        info_path = dataset_path / "meta" / "info.json"
        with open(info_path, 'r') as f:
            info = json.load(f)

        # 检查前5个episode的视频文件
        for episode_id in range(min(5, info["total_episodes"])):
            episode_chunk = episode_id // info.get("chunks_size", 1000)

            for video_key in ["laptop", "phone"]:
                video_file = dataset_path / f"videos/chunk-{episode_chunk:03d}/{video_key}/episode_{episode_id:06d}.mp4"

                # 视频文件可能不存在，但如果存在应该有合理的大小
                if video_file.exists():
                    assert video_file.stat().st_size > 1000, f"Video file {video_file} is too small"
```

### 6.7 测试执行与报告

#### 6.7.1 测试执行命令
```bash
# 安装测试依赖
pip install pytest pytest-cov selenium

# 运行所有测试
pytest tests/ -v --cov=core --cov=web --cov-report=html

# 运行特定测试类别
pytest tests/test_data_loader.py -v          # 单元测试
pytest tests/test_api.py -v                  # API测试
pytest tests/test_e2e.py -v                  # 端到端测试
pytest tests/test_performance.py -v          # 性能测试

# 生成测试报告
pytest tests/ --html=reports/test_report.html --self-contained-html
```

#### 6.7.2 持续集成配置
```yaml
# .github/workflows/test.yml (GitHub Actions)
name: Test Suite

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-cov selenium

    - name: Run unit tests
      run: pytest tests/test_*.py -x --cov=core --cov=web

    - name: Run integration tests
      run: pytest tests/test_api.py tests/test_web_pages.py -x

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
```

### 6.8 测试数据管理

#### 6.8.1 测试数据准备
```python
# tests/conftest.py - 测试配置和固件
import pytest
import tempfile
import shutil
from pathlib import Path
import json
import pandas as pd
import numpy as np

@pytest.fixture(scope="session")
def mock_dataset():
    """创建模拟数据集用于测试"""
    temp_dir = Path(tempfile.mkdtemp())

    # 创建目录结构
    (temp_dir / "meta").mkdir()
    (temp_dir / "data" / "chunk-000").mkdir(parents=True)
    (temp_dir / "videos" / "chunk-000" / "laptop").mkdir(parents=True)
    (temp_dir / "videos" / "chunk-000" / "phone").mkdir(parents=True)

    # 创建info.json
    info_data = {
        "total_episodes": 3,
        "total_frames": 300,
        "fps": 30,
        "robot_type": "koch",
        "chunks_size": 1000,
        "data_path": "data/chunk-{episode_chunk:03d}/episode_{episode_index:06d}.parquet",
        "video_path": "videos/chunk-{episode_chunk:03d}/{video_key}/episode_{episode_index:06d}.mp4",
        "features": {
            "action": {
                "dtype": "float32",
                "shape": [6],
                "names": ["joint1", "joint2", "joint3", "joint4", "joint5", "gripper"]
            },
            "timestamp": {"dtype": "float32", "shape": [1]}
        }
    }

    with open(temp_dir / "meta" / "info.json", 'w') as f:
        json.dump(info_data, f)

    # 创建示例parquet文件
    for episode_id in range(3):
        df_data = {
            "timestamp": np.linspace(0, 10, 100),
            "action": np.random.random((100, 6)).astype(np.float32)
        }
        df = pd.DataFrame({
            "timestamp": df_data["timestamp"],
            "action": [row for row in df_data["action"]]
        })

        parquet_path = temp_dir / f"data/chunk-000/episode_{episode_id:06d}.parquet"
        df.to_parquet(parquet_path)

    yield temp_dir

    # 清理
    shutil.rmtree(temp_dir)

@pytest.fixture
def app_config():
    """测试用应用配置"""
    return {
        "app": {"host": "127.0.0.1", "port": 9090, "debug": True},
        "dataset": {"cache_enabled": False},
        "ui": {"episodes_per_page": 10}
    }
```

## 7. 项目总结与展望

### 7.1 项目价值

本架构文档为从复杂的LeRobot机器人学习系统中提取核心可视化功能提供了完整的技术方案。通过精确的分析和设计，我们实现了：

- **功能精简**: 将479行的复杂脚本重构为模块化的架构
- **依赖最小化**: 从数十个依赖减少到5个核心依赖
- **本地化适配**: 专门针对grasp_dataset数据格式优化
- **架构清晰**: 采用分层设计，职责分离明确

### 7.2 技术特色

- **零冗余设计**: 移除所有非可视化相关功能
- **前后端分离**: 后端专注数据服务，前端负责交互渲染
- **性能优化**: 针对本地数据访问进行优化
- **可维护性**: 清晰的模块结构和完整的测试覆盖

### 7.3 应用前景

该最小化可视化系统可以作为：
- 机器人学习数据的快速预览工具
- 研究团队的数据分析基础平台
- 更复杂可视化系统的起始模板
- 教学演示和原型验证工具

通过这个架构文档和实施方案，开发团队可以高效地构建出专注、稳定、易用的机器人数据可视化工具。

---

**文档版本**: v1.0
**创建日期**: 2025-01-15
**预计实施周期**: 6个工作日
**目标用户**: 机器人学习研究团队
```
