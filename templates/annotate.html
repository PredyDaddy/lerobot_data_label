<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/static/js/alpine.min.js" defer></script>
    <script src="/static/js/annotator.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/static/css/lerobot-logo.css">
    <title>æ ‡æ³¨ Episode {{ episode_id }} - {{ dataset_info.repo_id }}</title>
</head>

<body class="flex flex-col md:flex-row h-screen max-h-screen bg-slate-950 text-gray-200" x-data="createAnnotationData()">
    <!-- Sidebar -->
    <div x-ref="sidebar" class="bg-slate-900 p-5 break-words overflow-y-auto shrink-0 md:shrink md:w-60 md:max-h-screen">
        <a href="#" @click.prevent="handleReturnToHome()" class="lerobot-logo block mb-4">
            LeRobot
        </a>
        <a href="#" @click.prevent="handleReturnToHome()" class="inline-flex items-center text-sm text-blue-400 hover:text-blue-300 mb-4 transition-colors">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
            </svg>
            è¿”å›æ•°æ®ç®¡ç†å¹³å°
        </a>
        <h1 class="mb-4 text-xl font-semibold">æ•°æ®æ ‡æ³¨</h1>

        <div class="mb-4 p-3 bg-slate-800 rounded">
            <div class="text-sm text-gray-400 mb-1">æ•°æ®é›†:</div>
            <div class="font-mono text-xs break-all" x-text="'{{ dataset_info.repo_id }}'"></div>
            <div class="text-xs text-gray-500 mt-1">
                <span>{{ dataset_info.num_episodes }} episodes</span>
                <span>| {{ dataset_info.fps }} fps</span>
            </div>
        </div>

        <!-- å½“å‰æ ‡æ³¨çŠ¶æ€ -->
        <div class="mb-4 p-3 bg-blue-900 border border-blue-700 rounded">
            <div class="text-sm text-blue-200 mb-1">æ­£åœ¨æ ‡æ³¨:</div>
            <div class="font-mono text-blue-100 font-semibold mb-3">Episode {{ episode_id }}</div>

            <!-- æ ‡æ³¨è¿›åº¦ç»Ÿè®¡ -->
            <div class="text-sm space-y-1 border-t border-blue-700 pt-2">
                <div class="text-blue-200">
                    <span>å·²æ ‡æ³¨: </span>
                    <span x-text="globalStats?.annotated_episodes_count || 0" class="font-mono text-blue-100"></span>
                    <span>/</span>
                    <span x-text="globalStats?.total_episodes_count || 0" class="font-mono text-blue-100"></span>
                    <span> æ¡æ•°æ®</span>
                </div>
                <div class="text-blue-200">
                    <span>æ€»æ ‡è®°æ®µè½æ•°: </span>
                    <span x-text="globalStats?.total_segments_count || 0" class="font-mono text-blue-100"></span>
                </div>
            </div>
            <div class="text-xs text-blue-300 mt-2" x-show="lastSaved">
                <span>æœ€åä¿å­˜: </span>
                <span x-text="formatTime(lastSaved)"></span>
            </div>
        </div>

        <!-- Episodeå¯¼èˆªæŒ‰é’® -->
        <div class="mb-4 space-y-2">
            <button @click="goToPreviousEpisode()"
                    class="w-full px-3 py-2 text-sm bg-slate-700 hover:bg-slate-600 rounded transition-colors"
                    :disabled="{{ episode_id }} === 0"
                    :class="{'opacity-50 cursor-not-allowed': {{ episode_id }} === 0}"
                    title="ä¸Šä¸€æ¡ (â†‘é”®)">
                â† ä¸Šä¸€æ¡Episode
            </button>
            <button @click="goToNextEpisode()"
                    class="w-full px-3 py-2 text-sm bg-slate-700 hover:bg-slate-600 rounded transition-colors"
                    :disabled="{{ episode_id }} === {{ episodes[-1] if episodes else 0 }}"
                    :class="{'opacity-50 cursor-not-allowed': {{ episode_id }} === {{ episodes[-1] if episodes else 0 }}}"
                    title="ä¸‹ä¸€æ¡ (â†“é”®)">
                ä¸‹ä¸€æ¡Episode â†’
            </button>
        </div>

        <!-- Episodesåˆ—è¡¨ -->
        <p class="text-sm font-medium mb-2">Episodes:</p>
        <!-- episodes menu for PC screens -->
        <div class="ml-2 block" x-data="episodePagination">
            <ul>
                <template x-for="episode in paginatedEpisodes" :key="episode">
                    <li class="font-mono text-sm mt-0.5">
                        <a @click="handleEpisodeNavigation(episode, $event)"
                           :href="'/annotate/' + episode"
                           :class="{
                               'inline-block px-2 py-1 rounded transition-colors': true,
                               'bg-blue-600 text-white font-bold': episode == {{ episode_id }},
                               'bg-green-100 text-green-800 hover:bg-green-200': episode != {{ episode_id }} && getSegmentCount(episode) > 0,
                               'text-gray-300 hover:bg-slate-700 hover:text-white': episode != {{ episode_id }} && getSegmentCount(episode) === 0,
                               'underline': true
                           }"
                           x-text="'Episode ' + episode + ' (' + getSegmentCount(episode) + ')'"></a>
                    </li>
                </template>
            </ul>

            <div class="flex items-center mt-3 text-xs" x-show="totalPages > 1">
                <button @click="prevPage()"
                        class="px-2 py-1 bg-slate-800 rounded mr-2"
                        :class="{'opacity-50 cursor-not-allowed': page === 1}"
                        :disabled="page === 1">
                    &laquo; Prev
                </button>
                <span class="font-mono mr-2" x-text="` ${page} / ${totalPages}`"></span>
                <button @click="nextPage()"
                        class="px-2 py-1 bg-slate-800 rounded"
                        :class="{'opacity-50 cursor-not-allowed': page === totalPages}"
                        :disabled="page === totalPages">
                    Next &raquo;
                </button>
            </div>
        </div>

        <!-- å¿«æ·é”®æç¤º -->
        <div class="text-xs text-gray-500">
            <div class="mb-2 font-medium">å¿«æ·é”®:</div>
            <div class="space-y-1">
                <div><span class="font-mono bg-slate-800 px-1 rounded">ç©ºæ ¼</span> æ’­æ”¾/æš‚åœ</div>
                <div><span class="font-mono bg-slate-800 px-1 rounded">â†/â†’</span> å•å¸§æ­¥è¿›</div>
                <div><span class="font-mono bg-slate-800 px-1 rounded">S</span> æ ‡è®°èµ·å§‹å¸§</div>
                <div><span class="font-mono bg-slate-800 px-1 rounded">E</span> æ ‡è®°ç»“æŸå¸§</div>
                <div><span class="font-mono bg-slate-800 px-1 rounded">A</span> æ·»åŠ æ®µè½</div>
                <div><span class="font-mono bg-slate-800 px-1 rounded">Ctrl+S</span> ä¿å­˜</div>
                <div><span class="font-mono bg-slate-800 px-1 rounded">â†‘/â†“</span> ä¸Šä¸€æ¡/ä¸‹ä¸€æ¡</div>
            </div>
        </div>
    </div>

    <!-- Toggle sidebar button -->
    <button class="flex items-center opacity-50 hover:opacity-100 mx-1 hidden md:block"
        @click="() => ($refs.sidebar.classList.toggle('hidden'))" title="Toggle sidebar">
        <div class="bg-slate-500 w-2 h-10 rounded-full"></div>
    </button>

    <!-- Content -->
    <div class="max-h-screen flex flex-col gap-4 overflow-y-auto md:flex-1 p-4">
        <!-- é¡µé¢å¤´éƒ¨ -->
        <div class="flex justify-between items-center">
            <h1 class="text-xl font-bold font-mono">æ ‡æ³¨ Episode {{ episode_id }}</h1>
            <div class="flex items-center gap-2">
                <div x-show="saving" class="text-sm text-yellow-400 flex items-center">
                    <div class="animate-spin mr-2">â³</div>
                    ä¿å­˜ä¸­...
                </div>
                <div x-show="saveStatus === 'success'" class="text-sm text-green-400">
                    âœ“ å·²ä¿å­˜
                </div>
                <div x-show="saveStatus === 'error'" class="text-sm text-red-400">
                    âœ— ä¿å­˜å¤±è´¥
                </div>
            </div>
        </div>

        <!-- é”™è¯¯æç¤º -->
        <div x-show="errorMessage"
             class="p-3 bg-red-900 border border-red-700 text-red-200 rounded"
             x-text="errorMessage">
        </div>

        <!-- è§†é¢‘è¿‡æ»¤ä¸‹æ‹‰èœå• -->
        <div class="max-w-32 relative text-sm mb-4 select-none" @click.outside="isVideosDropdownOpen = false">
            <div @click="isVideosDropdownOpen = !isVideosDropdownOpen"
                class="p-2 border border-slate-500 rounded flex justify-between items-center cursor-pointer">
                <span class="truncate">è¿‡æ»¤è§†é¢‘</span>
                <div class="transition-transform" :class="{ 'rotate-180': isVideosDropdownOpen }">ğŸ”½</div>
            </div>

            <div x-show="isVideosDropdownOpen"
                class="absolute mt-1 border border-slate-500 rounded shadow-lg z-10">
                <div>
                    <template x-for="video in videoKeys" :key="video">
                        <div @click="toggleVideoVisibility(video)"
                            class="p-2 cursor-pointer bg-slate-900"
                            :class="{ 'bg-slate-700': visibleVideos.includes(video) }"
                            x-text="video">
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- è§†é¢‘æ’­æ”¾åŒºåŸŸ -->
        <div class="flex flex-wrap gap-x-2 gap-y-6 mb-4">
            {% for video_info in videos_info %}
            <div x-show="visibleVideos.includes('{{ video_info.filename }}')" class="max-w-96 relative">
                <p class="absolute inset-x-0 -top-4 text-sm text-gray-300 bg-gray-800 px-2 rounded-t-xl truncate">{{ video_info.filename }}</p>
                <video muted loop type="video/mp4" class="object-contain w-full h-full"
                       @timeupdate="onTimeUpdate"
                       @loadedmetadata="onVideoLoaded"
                       @canplaythrough="videoCanPlay"
                       @ended="onVideoEnded">
                    <source src="{{ video_info.url }}">
                    Your browser does not support the video tag.
                </video>
            </div>
            {% endfor %}
        </div>

        <!-- æ’­æ”¾æ§åˆ¶å™¨ -->
        <div class="bg-slate-900 p-4 rounded-lg">
            <div class="flex gap-1 text-3xl items-center mb-4">
                <button x-ref="btnPlay" class="-rotate-90" title="æ’­æ”¾ (ç©ºæ ¼é”®)"
                        @click="playAllVideos()">ğŸ”½</button>
                <button x-ref="btnPause" class="hidden" title="æš‚åœ (ç©ºæ ¼é”®)"
                        @click="pauseAllVideos()">â¸ï¸</button>
                <button title="åé€€5ç§’"
                        @click="seekRelative(-5)">âª</button>
                <button title="å‰è¿›5ç§’"
                        @click="seekRelative(5)">â©</button>
                <button title="å›åˆ°å¼€å§‹"
                        @click="seekTo(0)">â†©ï¸</button>
                <input x-ref="slider" max="100" min="0" step="0.1" type="range" value="0"
                       class="w-80 mx-2" @input="onSliderInput" />
                <div x-ref="timer" class="font-mono text-sm border border-slate-500 rounded-lg px-1 py-0.5 shrink-0">
                    0:00 / 0:00
                </div>
            </div>

            <!-- å¸§ä¿¡æ¯æ˜¾ç¤º -->
            <div class="flex justify-between text-sm text-gray-400">
                <div>
                    <span>å½“å‰å¸§: </span>
                    <span x-text="currentFrame" class="font-mono text-white"></span>
                    <span> / </span>
                    <span x-text="totalFrames" class="font-mono text-white"></span>
                </div>
                <div>
                    <span>å½“å‰æ—¶é—´: </span>
                    <span x-text="formatTime(currentTime)" class="font-mono text-white"></span>
                </div>
            </div>
        </div>

        <!-- ä»»åŠ¡ä¿¡æ¯ç¼–è¾‘åŒº -->
        <div class="bg-slate-900 p-4 rounded-lg mb-4">
            <h3 class="text-lg font-semibold mb-4">ä»»åŠ¡ä¿¡æ¯ <span class="text-red-400">*</span></h3>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm mb-1">ä»»åŠ¡åç§°:</label>
                    <div class="relative">
                        <input type="text"
                               x-model="annotationData.task_name"
                               placeholder="è¯·è¾“å…¥ä»»åŠ¡åç§°ï¼ˆå¿…å¡«ï¼‰"
                               class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded pr-10">
                        <button @click="showTaskNameHistory = !showTaskNameHistory"
                                class="absolute right-2 top-2 text-blue-400 hover:text-blue-300"
                                title="é€‰æ‹©å†å²è®°å½•">
                            ğŸ“‹
                        </button>
                        <div x-show="showTaskNameHistory"
                             class="absolute z-20 mt-1 w-full bg-slate-700 border border-slate-600 rounded shadow-lg max-h-40 overflow-y-auto"
                             @click.outside="showTaskNameHistory = false">
                            <input type="text"
                                   x-model="taskNameFilter"
                                   placeholder="æœç´¢å†å²ä»»åŠ¡..."
                                   class="w-full px-3 py-2 bg-slate-600 border-b border-slate-500 text-sm">
                            <template x-for="task in filteredTaskNames" :key="task">
                                <div @click="selectTaskName(task); showTaskNameHistory = false"
                                     class="px-3 py-2 hover:bg-slate-600 cursor-pointer text-sm"
                                     x-text="task">
                                </div>
                            </template>
                        </div>
                    </div>
                    <div x-show="!annotationData.task_name?.trim()" class="text-xs text-red-400 mt-1">
                        ä»»åŠ¡åç§°ä¸èƒ½ä¸ºç©º
                    </div>
                </div>
                <div>
                    <label class="block text-sm mb-1">åˆå§‹åœºæ™¯æè¿°:</label>
                    <div class="relative">
                        <textarea x-model="annotationData.init_scene_text"
                                  rows="3"
                                  placeholder="è¯·è¾“å…¥åˆå§‹åœºæ™¯æè¿°ï¼ˆå¿…å¡«ï¼‰"
                                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded resize-none pr-10"></textarea>
                        <button @click="showInitSceneHistory = !showInitSceneHistory"
                                class="absolute right-2 top-2 text-blue-400 hover:text-blue-300"
                                title="é€‰æ‹©å†å²è®°å½•">
                            ğŸ“‹
                        </button>
                        <div x-show="showInitSceneHistory"
                             class="absolute z-20 mt-1 w-full bg-slate-700 border border-slate-600 rounded shadow-lg max-h-40 overflow-y-auto"
                             @click.outside="showInitSceneHistory = false">
                            <input type="text"
                                   x-model="initSceneFilter"
                                   placeholder="æœç´¢å†å²åœºæ™¯..."
                                   class="w-full px-3 py-2 bg-slate-600 border-b border-slate-500 text-sm">
                            <template x-for="scene in filteredInitScenes" :key="scene">
                                <div @click="selectInitScene(scene); showInitSceneHistory = false"
                                     class="px-3 py-2 hover:bg-slate-600 cursor-pointer text-sm"
                                     x-text="scene">
                                </div>
                            </template>
                        </div>
                    </div>
                    <div x-show="!annotationData.init_scene_text?.trim()" class="text-xs text-red-400 mt-1">
                        åˆå§‹åœºæ™¯æè¿°ä¸èƒ½ä¸ºç©º
                    </div>
                </div>
            </div>
        </div>

        <!-- å¸§é€‰æ‹©å·¥å…· -->
        <div class="bg-slate-900 p-4 rounded-lg mb-4">
            <h3 class="text-lg font-semibold mb-4">å¸§é€‰æ‹©å·¥å…·</h3>
            <div class="flex gap-4 items-center flex-wrap">
                <div class="flex items-center gap-2">
                    <label class="text-sm">èµ·å§‹å¸§:</label>
                    <input type="number" x-model="quickFrameStart"
                           class="w-20 px-2 py-1 bg-slate-700 border border-slate-600 rounded text-sm"
                           min="0" :max="totalFrames - 1">
                    <button @click="setQuickFrameStart()"
                            class="px-2 py-1 text-xs bg-blue-600 hover:bg-blue-700 rounded">
                        æ ‡è®°å½“å‰å¸§ (S)
                    </button>
                </div>
                <div class="flex items-center gap-2">
                    <label class="text-sm">ç»“æŸå¸§:</label>
                    <input type="number" x-model="quickFrameEnd"
                           class="w-20 px-2 py-1 bg-slate-700 border border-slate-600 rounded text-sm"
                           min="0" :max="totalFrames - 1">
                    <button @click="setQuickFrameEnd()"
                            class="px-2 py-1 text-xs bg-green-600 hover:bg-green-700 rounded">
                        æ ‡è®°å½“å‰å¸§ (E)
                    </button>
                </div>
                <button @click="openAddSegmentModal()"
                        :disabled="quickFrameStart === null || quickFrameEnd === null || quickFrameStart >= quickFrameEnd"
                        class="px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed rounded font-medium">
                    æ·»åŠ æ®µè½ (A)
                </button>
            </div>
        </div>

        <!-- æ ‡æ³¨æ§åˆ¶ -->
        <div class="bg-slate-900 p-4 rounded-lg mb-4">
            <div class="flex justify-between items-center">
                <h3 class="text-lg font-semibold">æ ‡æ³¨æ§åˆ¶</h3>
                <button @click="saveAnnotations()"
                        :disabled="!canSave()"
                        class="px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed rounded font-medium">
                    ä¿å­˜æ ‡æ³¨ (Ctrl+S)
                </button>
            </div>

            <!-- åˆ é™¤æ“ä½œ -->
            <div class="flex gap-2 mb-4 border-t border-slate-700 pt-4">
                <button @click="deleteCurrentAnnotation()"
                        :disabled="!annotationData?.label_info?.action_config?.length"
                        class="px-4 py-2 bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 disabled:cursor-not-allowed rounded font-medium">
                    åˆ é™¤æœ¬æ¡æ ‡æ³¨
                </button>
                <button @click="deleteAllAnnotations()"
                        class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded font-medium">
                    åˆ é™¤å…¨éƒ¨æ ‡æ³¨
                </button>
            </div>

            <!-- æ®µè½åˆ—è¡¨ -->
            <div>
                <h4 class="text-md font-medium mb-3">æ ‡æ³¨æ®µè½</h4>
                <div x-show="!annotationData?.label_info?.action_config?.length"
                     class="text-gray-500 text-center py-4">
                    æš‚æ— æ ‡æ³¨æ®µè½
                </div>
                <div class="space-y-2">
                    <template x-for="(segment, index) in (annotationData?.label_info?.action_config || [])" :key="index">
                        <div @click="openEditSegmentModal(index)"
                             class="p-3 bg-slate-800 rounded border border-slate-700 hover:border-slate-600 cursor-pointer transition-colors">
                            <div class="flex justify-between items-start">
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span class="text-sm font-medium" x-text="segment.skill"></span>
                                        <span class="text-xs text-gray-500 font-mono">
                                            å¸§ <span x-text="segment.start_frame"></span> - <span x-text="segment.end_frame"></span>
                                        </span>
                                        <span class="text-xs text-gray-500">
                                            (<span x-text="segment.end_frame - segment.start_frame"></span> å¸§)
                                        </span>
                                    </div>
                                    <div class="text-sm text-gray-300" x-text="segment.action_text"></div>
                                </div>
                                <div class="flex gap-1" @click.stop>
                                    <button @click="openEditSegmentModal(index)"
                                            class="px-2 py-1 text-xs bg-yellow-600 hover:bg-yellow-700 rounded">
                                        ç¼–è¾‘
                                    </button>
                                    <button @click="deleteSegment(index)"
                                            class="px-2 py-1 text-xs bg-red-600 hover:bg-red-700 rounded">
                                        åˆ é™¤
                                    </button>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- æ•°æ®é›†åˆ†å‰² -->
        <div class="bg-slate-900 p-4 rounded-lg mb-4" x-data="{ showSplitPanel: false }">
            <div class="flex justify-between items-center cursor-pointer" @click="showSplitPanel = !showSplitPanel">
                <h3 class="text-lg font-semibold">æ•°æ®é›†åˆ†å‰²</h3>
                <span x-text="showSplitPanel ? 'â–¼' : 'â–¶'"></span>
            </div>

            <div x-show="showSplitPanel" x-collapse class="mt-4 space-y-4">
                <!-- è¾“å‡ºç›®å½•è®¾ç½® -->
                <div>
                    <label class="block text-sm mb-1">è¾“å‡ºæ ¹ç›®å½•:</label>
                    <input type="text" x-model="splitConfig.outputRoot"
                           class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded text-white"
                           placeholder="/home/chenqingyu/robot/lerobot_data/output">
                </div>

                <!-- åˆ†å‰²è¯´æ˜ -->
                <div class="text-sm text-gray-400">
                    å°†è‡ªåŠ¨ä»æ ‡æ³¨æ•°æ®ä¸­æå–æ‰€æœ‰æŠ€èƒ½å¹¶åˆ†åˆ«åˆ›å»ºæ•°æ®é›†
                </div>

                <!-- åˆ†å‰²æŒ‰é’® -->
                <button @click="startDatasetSplit()"
                        :disabled="splitting"
                        class="px-4 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:cursor-not-allowed rounded font-medium">
                    <span x-show="!splitting">å¼€å§‹åˆ†å‰²æ•°æ®é›†</span>
                    <span x-show="splitting">åˆ†å‰²ä¸­...</span>
                </button>

                <!-- åˆ†å‰²çŠ¶æ€æ˜¾ç¤º -->
                <div x-show="splitStatus" class="text-sm" :class="splitSuccess ? 'text-green-400' : 'text-red-400'" x-text="splitStatus"></div>
            </div>
        </div>
    </div>

    <!-- æ®µè½ç¼–è¾‘æ¨¡æ€æ¡† -->
    <div x-show="showSegmentModal"
         class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4"
         @click.self="closeModal()">
        <div class="bg-slate-800 rounded-lg p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold" x-text="modalMode === 'add' ? 'æ·»åŠ æ–°æ®µè½' : 'ç¼–è¾‘æ®µè½'"></h3>
                <button @click="closeModal()" class="text-gray-400 hover:text-gray-200">
                    âœ•
                </button>
            </div>

            <!-- æ¨¡æ€æ¡†å†…çš„æ®µè½ç¼–è¾‘è¡¨å• -->
            <div class="space-y-4">
                <!-- å¸§èŒƒå›´è®¾ç½® -->
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm mb-1">èµ·å§‹å¸§:</label>
                        <input type="number" x-model="modalSegment.start_frame"
                               class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded text-sm"
                               min="0" :max="totalFrames - 1">
                    </div>
                    <div>
                        <label class="block text-sm mb-1">ç»“æŸå¸§:</label>
                        <input type="number" x-model="modalSegment.end_frame"
                               class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded text-sm"
                               min="0" :max="totalFrames - 1">
                    </div>
                </div>

                <!-- æŠ€èƒ½é€‰æ‹© -->
                <div>
                    <label class="block text-sm mb-1">åŠ¨ä½œç±»å‹ (skill):</label>
                    <div class="relative">
                        <select x-model="modalSegment.skill"
                                class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded pr-10">
                            <option value="">è¯·é€‰æ‹©...</option>
                            <template x-for="skill in historicalData.skills" :key="skill">
                                <option :value="skill" x-text="skill"></option>
                            </template>
                            <option value="__custom__">+ æ·»åŠ è‡ªå®šä¹‰æŠ€èƒ½</option>
                        </select>
                        <button @click="showSkillManager = !showSkillManager"
                                class="absolute right-2 top-2 text-blue-400 hover:text-blue-300"
                                title="ç®¡ç†æŠ€èƒ½">
                            âš™ï¸
                        </button>
                    </div>
                    <!-- è‡ªå®šä¹‰æŠ€èƒ½è¾“å…¥ -->
                    <div x-show="modalSegment.skill === '__custom__'" class="mt-2">
                        <input type="text" x-model="customSkillName"
                               placeholder="è¾“å…¥æ–°çš„æŠ€èƒ½åç§°"
                               class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded text-sm">
                    </div>
                    <!-- æŠ€èƒ½ç®¡ç†é¢æ¿ -->
                    <div x-show="showSkillManager"
                         class="mt-2 p-3 bg-slate-700 border border-slate-600 rounded"
                         @click.outside="showSkillManager = false">
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="text-sm font-medium">æŠ€èƒ½ç®¡ç†</h4>
                            <button @click="showSkillManager = false" class="text-gray-400 hover:text-gray-200">
                                âœ•
                            </button>
                        </div>

                        <!-- æŠ€èƒ½åˆ—è¡¨ -->
                        <div class="space-y-2 max-h-40 overflow-y-auto">
                            <template x-for="skill in historicalData.skills" :key="skill">
                                <div class="flex justify-between items-center p-2 bg-slate-600 rounded">
                                    <span class="text-sm" x-text="skill"></span>
                                    <div class="flex gap-1">
                                        <button @click="renameSkill(skill)"
                                                class="px-2 py-1 text-xs bg-yellow-600 hover:bg-yellow-700 rounded"
                                                title="é‡å‘½å">
                                            âœï¸
                                        </button>
                                        <button @click="checkSkillUsageAndDelete(skill)"
                                                class="px-2 py-1 text-xs bg-red-600 hover:bg-red-700 rounded"
                                                title="åˆ é™¤">
                                            ğŸ—‘ï¸
                                        </button>
                                    </div>
                                </div>
                            </template>
                        </div>

                        <!-- æŠ€èƒ½ç®¡ç†çŠ¶æ€æç¤º -->
                        <div x-show="skillManageMessage"
                             class="mt-2 text-sm text-green-400"
                             x-text="skillManageMessage">
                        </div>
                        <div x-show="skillManageError"
                             class="mt-2 text-sm text-red-400"
                             x-text="skillManageError">
                        </div>
                    </div>
                </div>

                <!-- åŠ¨ä½œæè¿° -->
                <div>
                    <label class="block text-sm mb-1">åŠ¨ä½œæè¿° (action_text):</label>
                    <div class="relative">
                        <textarea x-model="modalSegment.action_text"
                                  rows="4"
                                  placeholder="è¯·è¾“å…¥åŠ¨ä½œæè¿°"
                                  class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded resize-none pr-10"></textarea>
                        <button @click="showActionHistory = !showActionHistory"
                                class="absolute right-2 top-2 text-blue-400 hover:text-blue-300"
                                title="é€‰æ‹©å†å²è®°å½•">
                            ğŸ“‹
                        </button>
                        <!-- å†å²åŠ¨ä½œé€‰æ‹© -->
                        <div x-show="showActionHistory"
                             class="absolute z-20 mt-1 w-full bg-slate-700 border border-slate-600 rounded shadow-lg max-h-40 overflow-y-auto"
                             @click.outside="showActionHistory = false">
                            <input type="text"
                                   x-model="actionFilter"
                                   placeholder="æœç´¢å†å²åŠ¨ä½œ..."
                                   class="w-full px-3 py-2 bg-slate-600 border-b border-slate-500 text-sm">
                            <template x-for="action in filteredActions" :key="action">
                                <div @click="selectAction(action); showActionHistory = false"
                                     class="px-3 py-2 hover:bg-slate-600 cursor-pointer text-sm"
                                     x-text="action">
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="text-xs text-gray-500 mt-1">
                        <span x-text="(modalSegment.action_text || '').length"></span> / 500 å­—ç¬¦
                    </div>
                </div>

                <!-- éªŒè¯æç¤º -->
                <div x-show="modalError" class="text-red-400 text-sm" x-text="modalError"></div>
            </div>

            <!-- æ¨¡æ€æ¡†æŒ‰é’® -->
            <div class="flex justify-end gap-2 mt-6">
                <button @click="closeModal()"
                        class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded font-medium">
                    å–æ¶ˆ
                </button>
                <button @click="saveSegmentFromModal()"
                        :disabled="!canSaveFromModal()"
                        class="px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed rounded font-medium">
                    <span x-text="modalMode === 'add' ? 'æ·»åŠ æ®µè½' : 'ä¿å­˜ä¿®æ”¹'"></span>
                </button>
            </div>
        </div>
    </div>

    <script>
        function createAnnotationData() {
            return {
                // åŸºç¡€çŠ¶æ€
                videos: null,
                videoKeys: {{ videos_info | map(attribute='filename') | list | tojson }},
                visibleVideos: [],
                isVideosDropdownOpen: false,

                // æ—¶é—´å’Œå¸§çŠ¶æ€
                currentTime: 0,
                totalTime: 0,
                currentFrame: 0,
                totalFrames: 0,
                fps: {{ dataset_info.fps }},

                // æ ‡æ³¨çŠ¶æ€
                annotationData: null,
                annotationStats: {}, // å­˜å‚¨æ¯ä¸ªepisodeçš„æ®µè½ç»Ÿè®¡
                globalStats: {       // å­˜å‚¨å…¨å±€ç»Ÿè®¡æ•°æ®
                    annotated_episodes_count: 0,
                    total_episodes_count: 0,
                    total_segments_count: 0
                },

                // å¿«é€Ÿå¸§é€‰æ‹©ï¼ˆç”¨äºä¸»ç•Œé¢å¿«é€Ÿæ ‡è®°ï¼‰
                quickFrameStart: null,
                quickFrameEnd: null,

                // æ¨¡æ€æ¡†çŠ¶æ€
                showSegmentModal: false,
                modalMode: 'add', // 'add' | 'edit'
                modalSegmentIndex: -1,
                modalSegment: {
                    start_frame: null,
                    end_frame: null,
                    skill: '',
                    action_text: ''
                },
                modalError: '',
                customSkillName: '',

                // å†å²æ•°æ®é€‰æ‹©çŠ¶æ€
                showTaskNameHistory: false,
                showInitSceneHistory: false,
                showActionHistory: false,
                showSkillManager: false,
                taskNameFilter: '',
                initSceneFilter: '',
                actionFilter: '',

                // æŠ€èƒ½ç®¡ç†çŠ¶æ€
                skillManageMessage: '',
                skillManageError: '',

                // UIçŠ¶æ€
                saving: false,
                saveStatus: '',
                lastSaved: null,
                errorMessage: '',

                // å†å²æ•°æ®çŠ¶æ€
                historicalData: {
                    task_names: [],
                    init_scenes: [],
                    actions: [],
                    skills: []
                },
                // æ•°æ®é›†åˆ†å‰²é…ç½®
                splitConfig: {
                    outputRoot: '/home/chenqingyu/robot/lerobot_data/output'
                },
                splitting: false,
                splitStatus: '',
                splitSuccess: false,

                // å†å²æ•°æ®è¿‡æ»¤è®¡ç®—å±æ€§
                get filteredTaskNames() {
                    return this.historicalData.task_names.filter(name =>
                        name.toLowerCase().includes(this.taskNameFilter.toLowerCase())
                    );
                },

                get filteredInitScenes() {
                    return this.historicalData.init_scenes.filter(scene =>
                        scene.toLowerCase().includes(this.initSceneFilter.toLowerCase())
                    );
                },

                get filteredActions() {
                    return this.historicalData.actions.filter(action =>
                        action.toLowerCase().includes(this.actionFilter.toLowerCase())
                    );
                },
                async init() {
                    // åˆå§‹åŒ–è§†é¢‘æ˜¾ç¤º
                    this.visibleVideos = [...this.videoKeys];

                    // è·å–è§†é¢‘å…ƒç´ 
                    this.videos = document.querySelectorAll('video');

                    // å¹¶è¡ŒåŠ è½½æ ‡æ³¨æ•°æ®å’Œå†å²æ•°æ®
                    await Promise.all([
                        this.loadAnnotations(),
                        this.loadHistoricalData(),
                        this.loadAnnotationStats()
                    ]);

                    // ä»episodes.jsonlè‡ªåŠ¨å¡«å……é»˜è®¤å€¼
                    this.fillDefaultValuesFromEpisodeTasks();

                    // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬
                    this.setupKeyboardHandlers();
                },

                // å†å²æ•°æ®é€‰æ‹©æ–¹æ³•
                selectTaskName(taskName) {
                    this.annotationData.task_name = taskName;
                    this.taskNameFilter = '';
                },

                selectInitScene(scene) {
                    this.annotationData.init_scene_text = scene;
                    this.initSceneFilter = '';
                },

                selectAction(action) {
                    this.modalSegment.action_text = action;
                    this.actionFilter = '';
                },

                // ä»episodes.jsonlè‡ªåŠ¨å¡«å……é»˜è®¤å€¼
                fillDefaultValuesFromEpisodeTasks() {
                    // è·å–ä»åç«¯ä¼ é€’çš„episode tasksæ•°æ®
                    const episodeTasks = {{ episode_tasks | tojson }};

                    // åªæœ‰åœ¨å½“å‰æ ‡æ³¨æ•°æ®ä¸ºç©ºæˆ–è€…ä»»åŠ¡åç§°å’Œåˆå§‹åœºæ™¯æè¿°éƒ½ä¸ºç©ºæ—¶æ‰è‡ªåŠ¨å¡«å……
                    if (episodeTasks && episodeTasks.length > 0 && this.annotationData) {
                        const shouldFillTaskName = !this.annotationData.task_name || this.annotationData.task_name.trim() === '';
                        const shouldFillInitScene = !this.annotationData.init_scene_text || this.annotationData.init_scene_text.trim() === '';

                        if (shouldFillTaskName || shouldFillInitScene) {
                            // ä½¿ç”¨ç¬¬ä¸€ä¸ªtaskä½œä¸ºé»˜è®¤å€¼
                            const firstTask = episodeTasks[0];

                            if (shouldFillTaskName) {
                                this.annotationData.task_name = firstTask;
                            }

                            if (shouldFillInitScene) {
                                // ä¸ºåˆå§‹åœºæ™¯æè¿°ç”Ÿæˆä¸€ä¸ªåŸºäºä»»åŠ¡çš„é»˜è®¤æè¿°
                                this.annotationData.init_scene_text = `${firstTask}`;
                            }
                        }
                    }
                },

                // å¿«é€Ÿå¸§é€‰æ‹©æ–¹æ³•
                setQuickFrameStart() {
                    this.quickFrameStart = this.currentFrame;
                },

                setQuickFrameEnd() {
                    this.quickFrameEnd = this.currentFrame;
                },

                // æ¨¡æ€æ¡†æ§åˆ¶æ–¹æ³•
                openAddSegmentModal() {
                    this.modalMode = 'add';
                    this.modalSegmentIndex = -1;
                    this.modalSegment = {
                        start_frame: this.quickFrameStart,
                        end_frame: this.quickFrameEnd,
                        skill: '',
                        action_text: ''
                    };
                    this.modalError = '';
                    this.customSkillName = '';
                    this.showSegmentModal = true;
                },

                openEditSegmentModal(index) {
                    const segment = this.annotationData.label_info.action_config[index];
                    this.modalMode = 'edit';
                    this.modalSegmentIndex = index;
                    this.modalSegment = {
                        start_frame: segment.start_frame,
                        end_frame: segment.end_frame,
                        skill: segment.skill,
                        action_text: segment.action_text
                    };
                    this.modalError = '';
                    this.customSkillName = '';
                    this.showSegmentModal = true;
                },

                closeModal() {
                    this.showSegmentModal = false;
                    this.showActionHistory = false;
                    this.modalError = '';
                },

                canSaveFromModal() {
                    const s = this.modalSegment;
                    const skill = s.skill === '__custom__' ? this.customSkillName : s.skill;
                    return s.start_frame !== null &&
                           s.end_frame !== null &&
                           s.start_frame < s.end_frame &&
                           skill &&
                           skill.trim() &&
                           s.action_text &&
                           s.action_text.trim().length >= 3;
                },

                saveSegmentFromModal() {
                    if (!this.canSaveFromModal()) {
                        this.modalError = 'è¯·æ£€æŸ¥æ‰€æœ‰å­—æ®µæ˜¯å¦æ­£ç¡®å¡«å†™';
                        return;
                    }

                    const skill = this.modalSegment.skill === '__custom__' ? this.customSkillName.trim() : this.modalSegment.skill;

                    const newSegment = {
                        start_frame: parseInt(this.modalSegment.start_frame),
                        end_frame: parseInt(this.modalSegment.end_frame),
                        skill: skill,
                        action_text: this.modalSegment.action_text.trim()
                    };

                    // æ£€æŸ¥é‡å 
                    if (this.checkOverlap(newSegment, this.modalSegmentIndex)) {
                        this.modalError = 'æ®µè½ä¸ç°æœ‰æ®µè½é‡å ï¼Œè¯·æ£€æŸ¥å¸§èŒƒå›´';
                        return;
                    }

                    // å¦‚æœæ˜¯è‡ªå®šä¹‰æŠ€èƒ½ï¼Œæ·»åŠ åˆ°å†å²è®°å½•
                    if (this.modalSegment.skill === '__custom__' && this.customSkillName.trim()) {
                        if (!this.historicalData.skills.includes(this.customSkillName.trim())) {
                            this.historicalData.skills.push(this.customSkillName.trim());
                            this.historicalData.skills.sort();
                        }
                    }

                    if (!this.annotationData.label_info) {
                        this.annotationData.label_info = { action_config: [] };
                    }

                    if (this.modalMode === 'edit') {
                        // ç¼–è¾‘ç°æœ‰æ®µè½
                        this.annotationData.label_info.action_config[this.modalSegmentIndex] = newSegment;
                    } else {
                        // æ·»åŠ æ–°æ®µè½
                        this.annotationData.label_info.action_config.push(newSegment);
                    }

                    this.closeModal();
                    this.errorMessage = '';

                    // ç«‹å³æ›´æ–°æœ¬åœ°ç»Ÿè®¡æ•°æ®
                    this.updateLocalStats();
                },

                // æŠ€èƒ½ç®¡ç†æ–¹æ³•
                async renameSkill(oldName) {
                    const newName = prompt('è¯·è¾“å…¥æ–°çš„æŠ€èƒ½åç§°:', oldName);
                    if (!newName || newName.trim() === oldName) {
                        return;
                    }

                    this.skillManageMessage = '';
                    this.skillManageError = '';

                    try {
                        const response = await fetch(`/api/skills/${encodeURIComponent(oldName)}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ new_name: newName.trim() })
                        });

                        const result = await response.json();
                        if (result.ok) {
                            // æ›´æ–°æœ¬åœ°æŠ€èƒ½åˆ—è¡¨
                            const index = this.historicalData.skills.indexOf(oldName);
                            if (index !== -1) {
                                this.historicalData.skills[index] = newName.trim();
                                this.historicalData.skills.sort();
                            }

                            // æ›´æ–°å½“å‰æ¨¡æ€æ¡†ä¸­çš„é€‰æ‹©
                            if (this.modalSegment.skill === oldName) {
                                this.modalSegment.skill = newName.trim();
                            }

                            this.skillManageMessage = result.message || `æŠ€èƒ½å·²é‡å‘½åä¸º "${newName.trim()}"`;
                            setTimeout(() => { this.skillManageMessage = ''; }, 3000);
                        } else {
                            this.skillManageError = result.error || 'é‡å‘½åå¤±è´¥';
                            setTimeout(() => { this.skillManageError = ''; }, 5000);
                        }
                    } catch (error) {
                        console.error('Error renaming skill:', error);
                        this.skillManageError = 'ç½‘ç»œé”™è¯¯ï¼Œé‡å‘½åå¤±è´¥';
                        setTimeout(() => { this.skillManageError = ''; }, 5000);
                    }
                },

                async checkSkillUsageAndDelete(skillName) {
                    this.skillManageMessage = '';
                    this.skillManageError = '';

                    try {
                        // å…ˆæ£€æŸ¥ä½¿ç”¨æƒ…å†µ
                        const usageResponse = await fetch(`/api/skills/${encodeURIComponent(skillName)}/usage`);
                        const usageResult = await usageResponse.json();

                        if (usageResult.is_used) {
                            this.skillManageError = `æŠ€èƒ½ "${skillName}" æ­£åœ¨è¢« ${usageResult.usage_count} ä¸ªepisodeä½¿ç”¨ï¼Œæ— æ³•åˆ é™¤`;
                            setTimeout(() => { this.skillManageError = ''; }, 5000);
                            return;
                        }

                        // ç¡®è®¤åˆ é™¤
                        if (!confirm(`ç¡®å®šè¦åˆ é™¤æŠ€èƒ½ "${skillName}" å—ï¼Ÿ`)) {
                            return;
                        }

                        // åˆ é™¤æŠ€èƒ½
                        const deleteResponse = await fetch(`/api/skills/${encodeURIComponent(skillName)}`, {
                            method: 'DELETE'
                        });

                        const deleteResult = await deleteResponse.json();
                        if (deleteResult.ok) {
                            // ä»æœ¬åœ°åˆ—è¡¨ä¸­ç§»é™¤
                            const index = this.historicalData.skills.indexOf(skillName);
                            if (index !== -1) {
                                this.historicalData.skills.splice(index, 1);
                            }

                            // å¦‚æœå½“å‰é€‰ä¸­çš„æ˜¯è¢«åˆ é™¤çš„æŠ€èƒ½ï¼Œæ¸…ç©ºé€‰æ‹©
                            if (this.modalSegment.skill === skillName) {
                                this.modalSegment.skill = '';
                            }

                            this.skillManageMessage = deleteResult.message || `æŠ€èƒ½ "${skillName}" å·²åˆ é™¤`;
                            setTimeout(() => { this.skillManageMessage = ''; }, 3000);
                        } else {
                            this.skillManageError = deleteResult.error || 'åˆ é™¤å¤±è´¥';
                            setTimeout(() => { this.skillManageError = ''; }, 5000);
                        }
                    } catch (error) {
                        console.error('Error deleting skill:', error);
                        this.skillManageError = 'ç½‘ç»œé”™è¯¯ï¼Œåˆ é™¤å¤±è´¥';
                        setTimeout(() => { this.skillManageError = ''; }, 5000);
                    }
                },

                // æ—¶é—´æ›´æ–°å¤„ç†
                onTimeUpdate(event) {
                    const video = event.target;
                    if (video && video.duration) {
                        this.currentTime = video.currentTime;
                        this.totalTime = video.duration;
                        this.currentFrame = Math.floor(this.currentTime * this.fps);
                        this.totalFrames = Math.floor(this.totalTime * this.fps);

                        // æ›´æ–°è¿›åº¦æ¡
                        const progress = (this.currentTime / this.totalTime) * 100;
                        this.$refs.slider.value = progress;

                        // æ›´æ–°æ—¶é—´æ˜¾ç¤º
                        this.$refs.timer.textContent = this.formatTime(this.currentTime) + ' / ' + this.formatTime(this.totalTime);

                        // åŒæ­¥å…¶ä»–è§†é¢‘
                        this.videos.forEach(v => {
                            if (v !== video && Math.abs(v.currentTime - this.currentTime) > 0.1) {
                                v.currentTime = this.currentTime;
                            }
                        });
                    }
                },

                onVideoLoaded(event) {
                    const video = event.target;
                    if (video.duration) {
                        this.totalTime = video.duration;
                        this.totalFrames = Math.floor(video.duration * this.fps);
                        this.$refs.timer.textContent = this.formatTime(0) + ' / ' + this.formatTime(video.duration);
                    }
                },

                videoCanPlay() {
                    // è§†é¢‘å‡†å¤‡å°±ç»ªçš„å¤„ç†
                },

                onVideoEnded() {
                    this.$refs.btnPlay.classList.remove('hidden');
                    this.$refs.btnPause.classList.add('hidden');
                },

                onSliderInput() {
                    const progress = this.$refs.slider.value;
                    const time = (this.totalTime * progress) / 100;
                    this.seekTo(time);
                },

                // æ’­æ”¾æ§åˆ¶æ–¹æ³•
                playAllVideos() {
                    this.videos.forEach(video => video.play());
                    this.$refs.btnPlay.classList.add('hidden');
                    this.$refs.btnPause.classList.remove('hidden');
                },

                pauseAllVideos() {
                    this.videos.forEach(video => video.pause());
                    this.$refs.btnPlay.classList.remove('hidden');
                    this.$refs.btnPause.classList.add('hidden');
                },

                seekTo(time) {
                    this.videos.forEach(video => {
                        video.currentTime = Math.max(0, Math.min(time, video.duration || 0));
                    });
                },

                seekRelative(seconds) {
                    this.seekTo(this.currentTime + seconds);
                },

                // è§†é¢‘æ˜¾ç¤ºæ§åˆ¶
                toggleVideoVisibility(videoKey) {
                    if (this.visibleVideos.includes(videoKey)) {
                        this.visibleVideos = this.visibleVideos.filter(v => v !== videoKey);
                    } else {
                        this.visibleVideos = [...this.visibleVideos, videoKey];
                    }
                },

                // æ•°æ®æ£€æŸ¥æ–¹æ³•
                canSave() {
                    return !this.saving &&
                           this.annotationData?.label_info?.action_config?.length > 0 &&
                           this.annotationData?.task_name?.trim() &&
                           this.annotationData?.init_scene_text?.trim();
                },

                async deleteSegment(index) {
                    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ ‡æ³¨æ®µè½å—ï¼Ÿ')) {
                        return;
                    }

                    // åˆ é™¤æ®µè½
                    this.annotationData.label_info.action_config.splice(index, 1);

                    // ç«‹å³æ›´æ–°æœ¬åœ°ç»Ÿè®¡
                    this.updateLocalStats();

                    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ®µè½ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ é™¤æ•´æ¡æ ‡æ³¨ï¼ˆä¸åˆ é™¤æœ¬æ¡æ ‡æ³¨é€»è¾‘ä¸€è‡´ï¼‰
                    if (this.annotationData.label_info.action_config.length === 0) {
                        try {
                            const response = await fetch(`/api/annotations/{{ episode_id }}`, {
                                method: 'DELETE'
                            });

                            const result = await response.json();
                            if (result.ok) {
                                // é‡ç½®ä¸ºç©ºçŠ¶æ€
                                this.annotationData = {
                                    episode_id: {{ episode_id }},
                                    label_info: { action_config: [] },
                                    task_name: '',
                                    init_scene_text: ''
                                };
                                this.errorMessage = '';
                                this.saveStatus = '';
                                // åˆ·æ–°ç»Ÿè®¡æ•°æ®
                                try {
                                    await this.refreshAnnotationStats();
                                } catch (statsError) {
                                    console.error('åˆ·æ–°ç»Ÿè®¡æ•°æ®å¤±è´¥:', statsError);
                                }
                            } else {
                                this.errorMessage = result.error || 'åˆ é™¤æ ‡æ³¨å¤±è´¥';
                            }
                        } catch (error) {
                            console.error('åˆ é™¤æ ‡æ³¨å¤±è´¥:', error);
                            this.errorMessage = 'ç½‘ç»œé”™è¯¯ï¼Œåˆ é™¤æ ‡æ³¨å¤±è´¥';
                        }
                        return;
                    }

                    // è‡ªåŠ¨ä¿å­˜åˆ°æœåŠ¡å™¨
                    try {
                        this.saving = true;
                        this.saveStatus = '';
                        this.errorMessage = '';

                        const response = await fetch(`/api/annotations/{{ episode_id }}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(this.annotationData)
                        });

                        const result = await response.json();
                        if (result.ok) {
                            this.saveStatus = 'success';
                            this.lastSaved = new Date();
                            // åˆ·æ–°ç»Ÿè®¡æ•°æ®
                            try {
                                await this.refreshAnnotationStats();
                            } catch (statsError) {
                                console.error('åˆ·æ–°ç»Ÿè®¡æ•°æ®å¤±è´¥:', statsError);
                                // ç»Ÿè®¡åˆ·æ–°å¤±è´¥ä¸åº”è¯¥å½±å“åˆ é™¤æˆåŠŸçš„çŠ¶æ€
                            }
                            setTimeout(() => { this.saveStatus = ''; }, 2000);
                        } else {
                            this.saveStatus = 'error';
                            this.errorMessage = result.error || 'åˆ é™¤åä¿å­˜å¤±è´¥';
                        }
                    } catch (error) {
                        console.error('åˆ é™¤æ®µè½åä¿å­˜å¤±è´¥:', error);
                        this.saveStatus = 'error';
                        this.errorMessage = 'ç½‘ç»œé”™è¯¯ï¼Œåˆ é™¤åä¿å­˜å¤±è´¥';
                    } finally {
                        this.saving = false;
                    }
                },

                checkOverlap(newSegment, editingIndex = -1) {
                    const segments = this.annotationData?.label_info?.action_config || [];
                    return segments.some((segment, index) => {
                        if (index === editingIndex) return false;
                        // åŠå¼€åŒºé—´é‡å æ£€æŸ¥: [a,b) å’Œ [c,d) é‡å å½“ä¸”ä»…å½“ max(a,c) < min(b,d)
                        return Math.max(newSegment.start_frame, segment.start_frame) <
                               Math.min(newSegment.end_frame, segment.end_frame);
                    });
                },

                // æ•°æ®åŠ è½½å’Œä¿å­˜
                async loadAnnotations() {
                    try {
                        const response = await fetch(`/api/annotations/{{ episode_id }}`);
                        const data = await response.json();
                        this.annotationData = data;
                    } catch (error) {
                        console.error('åŠ è½½æ ‡æ³¨æ•°æ®å¤±è´¥:', error);
                        this.annotationData = {
                            episode_id: {{ episode_id }},
                            label_info: { action_config: [] }
                        };
                    }
                },

                async loadHistoricalData() {
                    try {
                        // å¹¶è¡ŒåŠ è½½æ‰€æœ‰å†å²æ•°æ®
                        const [taskNamesRes, initScenesRes, actionsRes, skillsRes] = await Promise.all([
                            fetch('/api/history/task_names'),
                            fetch('/api/history/init_scenes'),
                            fetch('/api/history/actions'),
                            fetch('/api/history/skills')
                        ]);

                        const [taskNamesData, initScenesData, actionsData, skillsData] = await Promise.all([
                            taskNamesRes.json(),
                            initScenesRes.json(),
                            actionsRes.json(),
                            skillsRes.json()
                        ]);

                        this.historicalData = {
                            task_names: taskNamesData.task_names || [],
                            init_scenes: initScenesData.init_scenes || [],
                            actions: actionsData.actions || [],
                            skills: skillsData.skills || []
                        };
                    } catch (error) {
                        console.error('åŠ è½½å†å²æ•°æ®å¤±è´¥:', error);
                        // ä½¿ç”¨é»˜è®¤å€¼
                        this.historicalData = {
                            task_names: [],
                            init_scenes: [],
                            actions: [],
                            skills: ['Pick', 'Place', 'Move', 'Rotate', 'Push', 'Pull', 'Grasp', 'Release']
                        };
                    }

                    // å°†å½“å‰episodeçš„tasksæ•°æ®æ·»åŠ åˆ°å†å²åˆ—è¡¨ä¸­
                    this.addEpisodeTasksToHistory();
                },

                // å°†å½“å‰episodeçš„tasksæ•°æ®æ·»åŠ åˆ°å†å²åˆ—è¡¨
                addEpisodeTasksToHistory() {
                    // è·å–ä»åç«¯ä¼ é€’çš„episode tasksæ•°æ®
                    const episodeTasks = {{ episode_tasks | tojson }};

                    if (episodeTasks && episodeTasks.length > 0) {
                        episodeTasks.forEach(task => {
                            // æ·»åŠ åˆ°ä»»åŠ¡åç§°å†å²åˆ—è¡¨ï¼ˆå»é‡ï¼‰
                            if (task && task.trim() && !this.historicalData.task_names.includes(task.trim())) {
                                this.historicalData.task_names.push(task.trim());
                            }

                            // ä¸ºåˆå§‹åœºæ™¯æè¿°ç”ŸæˆåŸºäºä»»åŠ¡çš„æè¿°å¹¶æ·»åŠ åˆ°å†å²åˆ—è¡¨ï¼ˆå»é‡ï¼‰
                            const sceneDescription = `æ‰§è¡Œä»»åŠ¡: ${task.trim()}`;
                            if (!this.historicalData.init_scenes.includes(sceneDescription)) {
                                this.historicalData.init_scenes.push(sceneDescription);
                            }
                        });

                        // å¯¹åˆ—è¡¨è¿›è¡Œæ’åºä»¥ä¿æŒä¸€è‡´æ€§
                        this.historicalData.task_names.sort();
                        this.historicalData.init_scenes.sort();
                    }
                },

                async loadAnnotationStats() {
                    try {
                        const response = await fetch('/api/annotations/stats');
                        const data = await response.json();
                        this.annotationStats = data.stats || {};
                        this.globalStats = data.global_stats || {
                            annotated_episodes_count: 0,
                            total_episodes_count: 0,
                            total_segments_count: 0
                        };
                    } catch (error) {
                        console.error('åŠ è½½æ ‡æ³¨ç»Ÿè®¡å¤±è´¥:', error);
                        this.annotationStats = {};
                        this.globalStats = {
                            annotated_episodes_count: 0,
                            total_episodes_count: 0,
                            total_segments_count: 0
                        };
                    }
                },

                getSegmentCount(episodeId) {
                    return this.annotationStats[episodeId] || 0;
                },

                async saveAnnotations() {
                    if (this.saving) return;

                    // éªŒè¯å¿…å¡«å­—æ®µ
                    if (!this.canSave()) {
                        this.errorMessage = 'è¯·å¡«å†™ä»»åŠ¡åç§°ã€åˆå§‹åœºæ™¯æè¿°ï¼Œå¹¶è‡³å°‘æ·»åŠ ä¸€ä¸ªæ ‡æ³¨æ®µè½';
                        setTimeout(() => { this.errorMessage = ''; }, 3000);
                        return;
                    }

                    this.saving = true;
                    this.saveStatus = '';
                    this.errorMessage = '';

                    try {
                        const response = await fetch(`/api/annotations/{{ episode_id }}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(this.annotationData)
                        });

                        const result = await response.json();
                        if (result.ok) {
                            this.saveStatus = 'success';
                            this.lastSaved = new Date();
                            // åˆ·æ–°ç»Ÿè®¡æ•°æ®
                            try {
                                await this.refreshAnnotationStats();
                            } catch (statsError) {
                                console.error('åˆ·æ–°ç»Ÿè®¡æ•°æ®å¤±è´¥:', statsError);
                                // ç»Ÿè®¡åˆ·æ–°å¤±è´¥ä¸åº”è¯¥å½±å“ä¿å­˜æˆåŠŸçš„çŠ¶æ€
                            }
                            setTimeout(() => { this.saveStatus = ''; }, 2000);
                        } else {
                            this.saveStatus = 'error';
                            this.errorMessage = result.error || 'ä¿å­˜å¤±è´¥';
                        }
                    } catch (error) {
                        console.error('ä¿å­˜æ ‡æ³¨æ•°æ®å¤±è´¥:', error);
                        this.saveStatus = 'error';
                        this.errorMessage = 'ç½‘ç»œé”™è¯¯ï¼Œä¿å­˜å¤±è´¥';
                    } finally {
                        this.saving = false;
                    }
                },

                // å¯¼èˆªå‰çš„ä¿å­˜æ£€æŸ¥å’Œå¤„ç†å‡½æ•°
                async handleNavigationSave() {
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ ‡æ³¨æ®µè½
                    const hasSegments = this.annotationData?.label_info?.action_config?.length > 0;

                    if (!hasSegments) {
                        return true; // æ²¡æœ‰æ®µè½æ•°æ®ï¼Œå…è®¸ç›´æ¥è·³è½¬
                    }

                    // å¦‚æœæ•°æ®å®Œæ•´ï¼Œè‡ªåŠ¨ä¿å­˜
                    if (this.canSave()) {
                        try {
                            await this.saveAnnotations();
                            return true; // ä¿å­˜æˆåŠŸï¼Œå…è®¸è·³è½¬
                        } catch (error) {
                            console.error('è‡ªåŠ¨ä¿å­˜å¤±è´¥:', error);
                            // ä¿å­˜å¤±è´¥ï¼Œè¯¢é—®ç”¨æˆ·æ˜¯å¦ç»§ç»­
                            return confirm('è‡ªåŠ¨ä¿å­˜å¤±è´¥ï¼Œæ˜¯å¦ç»§ç»­è·³è½¬ï¼Ÿæœªä¿å­˜çš„æ•°æ®å°†ä¸¢å¤±ã€‚');
                        }
                    } else {
                        // æ•°æ®ä¸å®Œæ•´ï¼Œæç¤ºç”¨æˆ·
                        return confirm('å½“å‰æœ‰æœªä¿å­˜çš„æ ‡æ³¨æ®µè½ï¼Œä½†ä»»åŠ¡ä¿¡æ¯ä¸å®Œæ•´ã€‚\nç¦»å¼€å½“å‰é¡µé¢åï¼Œæœªä¿å­˜çš„æ ‡æ³¨æ®µè½å°†ä¼šä¸¢å¤±ã€‚\n\næ˜¯å¦è¦ç»§ç»­ç¦»å¼€ï¼Ÿ');
                    }
                },

                // åˆ é™¤åŠŸèƒ½
                async deleteCurrentAnnotation() {
                    if (!confirm('ç¡®å®šè¦åˆ é™¤å½“å‰episodeçš„æ‰€æœ‰æ ‡æ³¨å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                        return;
                    }

                    try {
                        const response = await fetch(`/api/annotations/{{ episode_id }}`, {
                            method: 'DELETE'
                        });

                        const result = await response.json();
                        if (result.ok) {
                            // é‡ç½®ä¸ºç©ºçŠ¶æ€
                            this.annotationData = {
                                episode_id: {{ episode_id }},
                                label_info: { action_config: [] },
                                task_name: '',
                                init_scene_text: ''
                            };
                            this.errorMessage = '';
                            this.saveStatus = '';
                            alert('æ ‡æ³¨å·²åˆ é™¤');
                            // åˆ·æ–°ç»Ÿè®¡æ•°æ®
                            try {
                                await this.refreshAnnotationStats();
                            } catch (statsError) {
                                console.error('åˆ·æ–°ç»Ÿè®¡æ•°æ®å¤±è´¥:', statsError);
                                // ç»Ÿè®¡åˆ·æ–°å¤±è´¥ä¸åº”è¯¥å½±å“åˆ é™¤æˆåŠŸçš„çŠ¶æ€
                            }
                        } else {
                            this.errorMessage = result.error || 'åˆ é™¤å¤±è´¥';
                        }
                    } catch (error) {
                        console.error('åˆ é™¤æ ‡æ³¨å¤±è´¥:', error);
                        this.errorMessage = 'ç½‘ç»œé”™è¯¯ï¼Œåˆ é™¤å¤±è´¥';
                    }
                },

                async deleteAllAnnotations() {
                    const confirmText = 'ç¡®å®šè¦åˆ é™¤æ‰€æœ‰æ•°æ®é›†çš„æ ‡æ³¨å—ï¼Ÿè¯·è¾“å…¥ DELETE ç¡®è®¤ï¼š';
                    const userInput = prompt(confirmText);

                    if (userInput !== 'DELETE') {
                        return;
                    }

                    try {
                        const response = await fetch('/api/annotations', {
                            method: 'DELETE',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ confirm: true })
                        });

                        const result = await response.json();
                        if (result.ok) {
                            // é‡ç½®ä¸ºç©ºçŠ¶æ€
                            this.annotationData = {
                                episode_id: {{ episode_id }},
                                label_info: { action_config: [] },
                                task_name: '',
                                init_scene_text: ''
                            };
                            this.errorMessage = '';
                            this.saveStatus = '';
                            alert(`å·²åˆ é™¤æ‰€æœ‰æ ‡æ³¨ (${result.deleted_count || 0} æ¡)`);
                            // åˆ·æ–°ç»Ÿè®¡æ•°æ®
                            try {
                                await this.refreshAnnotationStats();
                            } catch (statsError) {
                                console.error('åˆ·æ–°ç»Ÿè®¡æ•°æ®å¤±è´¥:', statsError);
                                // ç»Ÿè®¡åˆ·æ–°å¤±è´¥ä¸åº”è¯¥å½±å“åˆ é™¤æˆåŠŸçš„çŠ¶æ€
                            }
                        } else {
                            this.errorMessage = result.error || 'åˆ é™¤å¤±è´¥';
                        }
                    } catch (error) {
                        console.error('åˆ é™¤å…¨éƒ¨æ ‡æ³¨å¤±è´¥:', error);
                        this.errorMessage = 'ç½‘ç»œé”™è¯¯ï¼Œåˆ é™¤å¤±è´¥';
                    }
                },

                // Episodeå¯¼èˆª
                async goToNextEpisode() {
                    // æ£€æŸ¥å¹¶å¤„ç†ä¿å­˜é€»è¾‘
                    const canNavigate = await this.handleNavigationSave();
                    if (!canNavigate) {
                        return; // ç”¨æˆ·é€‰æ‹©ä¸ç»§ç»­è·³è½¬
                    }

                    try {
                        const response = await fetch(`/api/next_episode/{{ episode_id }}`);
                        const data = await response.json();
                        if (data.next_id !== undefined) {
                            // åˆ·æ–°ç»Ÿè®¡æ•°æ®
                            await this.refreshAnnotationStats();
                            window.location.href = `/annotate/${data.next_id}`;
                        }
                    } catch (error) {
                        console.error('è·å–ä¸‹ä¸€ä¸ªepisodeå¤±è´¥:', error);
                    }
                },

                async goToPreviousEpisode() {
                    // æ£€æŸ¥å¹¶å¤„ç†ä¿å­˜é€»è¾‘
                    const canNavigate = await this.handleNavigationSave();
                    if (!canNavigate) {
                        return; // ç”¨æˆ·é€‰æ‹©ä¸ç»§ç»­è·³è½¬
                    }

                    const prevId = {{ episode_id }} - 1;
                    if (prevId >= 0) {
                        // åˆ·æ–°ç»Ÿè®¡æ•°æ®
                        await this.refreshAnnotationStats();
                        window.location.href = `/annotate/${prevId}`;
                    }
                },

                // ç»Ÿä¸€çš„episodeå¯¼èˆªå¤„ç†å‡½æ•°
                async handleEpisodeNavigation(targetEpisode, event) {
                    if (event) {
                        event.preventDefault();
                    }

                    // å¦‚æœç‚¹å‡»çš„æ˜¯å½“å‰episodeï¼Œä¸éœ€è¦è·³è½¬
                    if (targetEpisode === {{ episode_id }}) {
                        return;
                    }

                    // æ£€æŸ¥å¹¶å¤„ç†ä¿å­˜é€»è¾‘
                    const canNavigate = await this.handleNavigationSave();
                    if (!canNavigate) {
                        return; // ç”¨æˆ·é€‰æ‹©ä¸ç»§ç»­è·³è½¬
                    }

                    // åˆ·æ–°ç»Ÿè®¡æ•°æ®å¹¶è·³è½¬
                    await this.refreshAnnotationStats();
                    window.location.href = `/annotate/${targetEpisode}`;
                },

                // åˆ·æ–°æ ‡æ³¨ç»Ÿè®¡æ•°æ®
                async refreshAnnotationStats() {
                    try {
                        const response = await fetch('/api/annotations/stats');
                        const data = await response.json();
                        this.annotationStats = data.stats || {};
                        this.globalStats = data.global_stats || {
                            annotated_episodes_count: 0,
                            total_episodes_count: 0,
                            total_segments_count: 0
                        };

                        // é€šçŸ¥episodePaginationç»„ä»¶æ›´æ–°ç»Ÿè®¡æ•°æ®
                        this.$dispatch('stats-updated', data.stats || {});
                    } catch (error) {
                        console.error('åˆ·æ–°æ ‡æ³¨ç»Ÿè®¡å¤±è´¥:', error);
                    }
                },

                // ç«‹å³æ›´æ–°æœ¬åœ°ç»Ÿè®¡æ•°æ®
                updateLocalStats() {
                    const currentEpisodeId = {{ episode_id }};
                    const segmentCount = this.annotationData?.label_info?.action_config?.length || 0;

                    // æ›´æ–°æœ¬åœ°ç»Ÿè®¡
                    this.annotationStats[currentEpisodeId] = segmentCount;

                    // é‡æ–°è®¡ç®—å…¨å±€ç»Ÿè®¡ï¼ˆåŸºäºæœ¬åœ°annotationStatsï¼‰
                    let annotatedCount = 0;
                    let totalSegments = 0;
                    for (const [episodeId, count] of Object.entries(this.annotationStats)) {
                        if (count > 0) {
                            annotatedCount++;
                            totalSegments += count;
                        }
                    }

                    // æ›´æ–°å…¨å±€ç»Ÿè®¡ï¼ˆä¿æŒtotal_episodes_countä¸å˜ï¼‰
                    this.globalStats = {
                        annotated_episodes_count: annotatedCount,
                        total_episodes_count: this.globalStats?.total_episodes_count || 0,
                        total_segments_count: totalSegments
                    };

                    // é€šçŸ¥episodePaginationç»„ä»¶æ›´æ–°
                    this.$dispatch('stats-updated', this.annotationStats);
                },

                hasUnsavedChanges() {
                    // ç®€å•æ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„æ›´æ”¹
                    return this.saveStatus !== 'success' &&
                           (this.annotationData?.label_info?.action_config?.length > 0 ||
                            this.currentSegment.skill || this.currentSegment.action_text);
                },

                // é”®ç›˜äº‹ä»¶å¤„ç†
                setupKeyboardHandlers() {
                    document.addEventListener('keydown', (e) => {
                        // é¿å…åœ¨è¾“å…¥æ¡†ä¸­è§¦å‘å¿«æ·é”®
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                            if (e.key === 'Escape') {
                                e.target.blur();
                            }
                            return;
                        }

                        switch (e.key) {
                            case ' ':
                                e.preventDefault();
                                if (this.$refs.btnPause.classList.contains('hidden')) {
                                    this.playAllVideos();
                                } else {
                                    this.pauseAllVideos();
                                }
                                break;
                            case 'ArrowLeft':
                                e.preventDefault();
                                this.seekRelative(-1/this.fps); // å•å¸§åé€€
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                this.seekRelative(1/this.fps); // å•å¸§å‰è¿›
                                break;
                            case 's':
                            case 'S':
                                e.preventDefault();
                                this.setQuickFrameStart();
                                break;
                            case 'e':
                            case 'E':
                                e.preventDefault();
                                this.setQuickFrameEnd();
                                break;
                            case 'a':
                            case 'A':
                                e.preventDefault();
                                if (this.quickFrameStart !== null && this.quickFrameEnd !== null && this.quickFrameStart < this.quickFrameEnd) {
                                    this.openAddSegmentModal();
                                }
                                break;
                            case 'ArrowUp':
                                e.preventDefault();
                                this.goToPreviousEpisode();
                                break;
                            case 'ArrowDown':
                                e.preventDefault();
                                this.goToNextEpisode();
                                break;
                        }

                        if (e.ctrlKey && e.key === 's') {
                            e.preventDefault();
                            this.saveAnnotations();
                        }
                    });
                },

                // è¿”å›æ•°æ®ç®¡ç†å¹³å°å¤„ç†ï¼ˆè‡ªåŠ¨ä¿å­˜ï¼‰
                async handleReturnToHome() {
                    // è‡ªåŠ¨ä¿å­˜ï¼šå¦‚æœæœ‰å¯ä¿å­˜çš„å†…å®¹å°±è‡ªåŠ¨ä¿å­˜ï¼ˆä¸episodeå¯¼èˆªé€»è¾‘ä¸€è‡´ï¼‰
                    if (this.canSave()) {
                        try {
                            await this.saveAnnotations();
                        } catch (error) {
                            console.error('è‡ªåŠ¨ä¿å­˜å¤±è´¥:', error);
                            // å¦‚æœè‡ªåŠ¨ä¿å­˜å¤±è´¥ï¼Œè¯¢é—®ç”¨æˆ·æ˜¯å¦ç»§ç»­
                            if (!confirm('è‡ªåŠ¨ä¿å­˜å¤±è´¥ï¼Œæ˜¯å¦ä»è¦è¿”å›æ•°æ®ç®¡ç†å¹³å°ï¼Ÿæœªä¿å­˜çš„æ•°æ®å°†ä¸¢å¤±ã€‚')) {
                                return;
                            }
                        }
                    }

                    // è·³è½¬åˆ°ä¸»é¡µ
                    window.location.href = '/';
                },

                // å·¥å…·æ–¹æ³•
                formatTime(time) {
                    if (isNaN(time)) return '0:00';
                    const hours = Math.floor(time / 3600);
                    const minutes = Math.floor((time % 3600) / 60);
                    const seconds = Math.floor(time % 60);
                    return (hours > 0 ? hours + ':' : '') +
                           (minutes < 10 ? '0' + minutes : minutes) + ':' +
                           (seconds < 10 ? '0' + seconds : seconds);
                },

                // æ•°æ®é›†åˆ†å‰²æ–¹æ³•
                async startDatasetSplit() {
                    if (!this.splitConfig.outputRoot.trim()) {
                        this.splitStatus = 'è¯·è®¾ç½®è¾“å‡ºæ ¹ç›®å½•';
                        this.splitSuccess = false;
                        return;
                    }

                    this.splitting = true;
                    this.splitStatus = '';

                    try {
                        const response = await fetch('/api/dataset/split_by_skill', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                output_root: this.splitConfig.outputRoot.trim()
                            })
                        });

                        const result = await response.json();

                        if (result.success) {
                            this.splitStatus = `åˆ†å‰²å®Œæˆï¼æˆåŠŸå¤„ç† ${result.processed_skills.length} ä¸ªæŠ€èƒ½: ${result.processed_skills.join(', ')}`;
                            this.splitSuccess = true;
                        } else {
                            this.splitStatus = `åˆ†å‰²å¤±è´¥: ${result.error}`;
                            this.splitSuccess = false;
                        }
                    } catch (error) {
                        this.splitStatus = `åˆ†å‰²å¤±è´¥: ${error.message}`;
                        this.splitSuccess = false;
                    } finally {
                        this.splitting = false;
                        setTimeout(() => {
                            this.splitStatus = '';
                        }, 5000);
                    }
                }
            };
        }

        // åœ¨Alpineåˆå§‹åŒ–æ—¶æ³¨å†Œç»„ä»¶
        document.addEventListener('alpine:init', () => {
            // Episodesåˆ†é¡µç»„ä»¶
            Alpine.data('episodePagination', () => ({
                episodes: {{ episodes }},
                pageSize: 100,
                page: 1,
                annotationStats: {},

                init() {
                    const currentEpisodeId = {{ episode_id }};
                    const episodeIndex = this.episodes.indexOf(currentEpisodeId);
                    if (episodeIndex !== -1) {
                        this.page = Math.floor(episodeIndex / this.pageSize) + 1;
                    }
                    // åŠ è½½æ ‡æ³¨ç»Ÿè®¡æ•°æ®
                    this.loadAnnotationStats();

                    // ç›‘å¬ç»Ÿè®¡æ•°æ®æ›´æ–°äº‹ä»¶
                    this.$el.addEventListener('stats-updated', (event) => {
                        this.annotationStats = event.detail;
                    });
                },

                async loadAnnotationStats() {
                    try {
                        const response = await fetch('/api/annotations/stats');
                        const data = await response.json();
                        this.annotationStats = data.stats || {};
                    } catch (error) {
                        console.error('åŠ è½½æ ‡æ³¨ç»Ÿè®¡å¤±è´¥:', error);
                        this.annotationStats = {};
                    }
                },

                get totalPages() {
                    return Math.ceil(this.episodes.length / this.pageSize);
                },

                get paginatedEpisodes() {
                    const start = (this.page - 1) * this.pageSize;
                    const end = start + this.pageSize;
                    return this.episodes.slice(start, end);
                },

                nextPage() {
                    if (this.page < this.totalPages) {
                        this.page++;
                    }
                },

                prevPage() {
                    if (this.page > 1) {
                        this.page--;
                    }
                },

                getSegmentCount(episodeId) {
                    return this.annotationStats[episodeId] || 0;
                }
            }));
        });
    </script>
</body>
</html>